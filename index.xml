<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>htakeuchi0 のノート</title><link>https://htakeuchi0.github.io/</link><description>Recent content on htakeuchi0 のノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Thu, 11 Aug 2022 12:18:39 +0900</lastBuildDate><atom:link href="https://htakeuchi0.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>プロジェクトマネジメント知識体系 (PMBOK) ガイドに関するノート</title><link>https://htakeuchi0.github.io/docs/others/pmbok/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/others/pmbok/</guid><description>プロジェクトマネジメント知識体系 (PMBOK) ガイドに関するノート # 概要 # 本ページでは，プロジェクトマネジメント協会 (PMI) が発行するプロジェクトマネジメント知識体系 (PMBOK) ガイドの第6版日本語版 [1]，第7版日本語版 [2] の違いについてまとめます．
はじめに # プロジェクトマネジメントに関する知識を体系化したものとして，プロジェクトマネジメント協会 (PMI) が発行する プロジェクトマネジメント知識体系 (PMBOK) ガイドが広く知られています．
近年 (2022年11月)， PMI 日本支部より，PMBOK ガイド第7版の日本語版 [2] が刊行されました．
本ページでは，PMBOK ガイド第6版日本語版 [1]，第7版日本語版 [2] の違いを中心に，それら概要をまとめます．
第6版・第7版の違い # 本節では，第6版日本語版・第7版日本語版（以下，単に第6版，第7版と呼ぶ）の違いについて述べます． この違いを明確にする目的で，第6版，第7版の概要をまとめます．
まず，第6版の概要は以下のとおりです．
PMBOK ガイドはプロジェクトマネジメント標準に基づきまたこれを含む． PMBOK ガイドおよびプロジェクトマネジメント標準は規律的実務慣行でなく，模範的実務慣行に基づく． PMBOK ガイドが述べるのは知識体系であり方法論ではない． プロジェクトマネジメント標準は特定のプロセスまたは実務慣行の実施を要求するものではない． プロジェクト・ライフサイクルは，プロジェクトマネジメント・プロセス（以下，プロセス）を実施することでマネジメントされる． プロセスはインプットがあり，ツールや技法の適用を経てアウトプットを生成するものである (ITTO)． プロセスは5個のプロジェクトマネジメント・プロセス群（以下，プロセス群）に分類される． プロセスは10個の知識エリアにも分類される． 知識エリアとは，知識に対する要求事項によって定義されたものである． プロセスは次の事項を通して，一貫した予測可能な実務慣行を可能とする1． 文書化できる． プロセスに対するパフォーマンスを評価できる． 効率を最大化し，脅威を最小化するようにプロセスを改善できる． PMBOK ガイドの後にプロジェクトマネジメント標準を置く構成とした． 次に，第7版の（特に第6版との差分に着目した）概要は以下のとおりです．
成果物でなく意図した成果をより重視するため，原理・原則ベースの標準に移行した． プロセスベースの標準は本質的に規範的である． 過去のプロセスベース指向では価値実現の全貌を示すための方法として維持できない． 過去の版のプロセスベース・アプローチとの整合を無効にする内容は存在しない． プロジェクトマネジメント標準の価値実現の全体観に始まり，その後 PMBOK ガイドの内容表現へと続く構成とした． 10個の知識エリアは8個のパフォーマンス領域へ変更した． PMBOK ガイドにテーラリング2 専用の章を設けた． PMBOK ガイドに「モデル，方法，作成物」という章を設けたが，これは ITTO とのリンクが維持され拡張されるものである． 以上より，価値実現・成果に重きがおかれるようになり，より実務的慣行に基づくようにするため，第6版までのプロセスベースでなく，原理・原則ベースの標準に移行した，という趣旨が読み取れます．</description></item><item><title>指数関数の定積分</title><link>https://htakeuchi0.github.io/docs/math/exp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/exp/</guid><description>指数関数の定積分 # 概要 # 本ページでは，指数関数に関するいくつかの定積分の求め方と結果を説明します． 指数関数 \(\exp:\mathbb{R}\to\mathbb{R}\) とは， \[\exp(x)=\sum_{k=0}^n\frac{x^k}{k!}\] で定められる関数であり， \(\exp&amp;#39;(x)=\exp(x)\) が成り立つことが知られています．
本ページでは，以下の定積分の求め方と結果をまとめます．
\(\int_{\alpha}^{\beta}\exp(x)dx\) \(\int_{\alpha}^{\beta}\exp(ax&amp;#43;b)dx\) \(\int_{\alpha}^{\beta}\exp(ax^2&amp;#43;bx&amp;#43;c)dx\quad(a&amp;lt;0)\) ただし，以下の関数を既知とします．この関数は，相補誤差関数と呼ばれ，たとえば C++ の標準ライブラリで std::erfc として定義されています． \[\mathrm{erfc}(x)=\frac{2}{\sqrt{\pi}}\int_x^{\infty}e^{-t^2}dt\] 定積分1 # まず， \(\int_{\alpha}^{\beta}\exp(x)dx\) を計算します． これは， \(\exp&amp;#39;(x)=\exp(x)\) なので， \[\int_{\alpha}^{\beta}\exp(x)dx=\exp(\beta)-\exp(\alpha)\] です．
定積分2 # 次に， \(\int_{\alpha}^{\beta}\exp(ax&amp;#43;b)dx\) を計算します． いま， \(y=ax&amp;#43;b\) とすると，
\(x=(y-b)/a\) , \(y=a\alpha&amp;#43;b\) ならば \(x=\alpha\) , \(y=a\beta&amp;#43;b\) ならば \(x=\beta\) です． \(dx/dy=1/a\) なので，
\[\begin{aligned} &amp;amp;\int_{\alpha}^{\beta}\exp(ax&amp;#43;b)dx\\ &amp;amp;=\int_{a\alpha&amp;#43;b}^{a\beta&amp;#43;b}\exp(y)\frac{dx}{dy}dy\\ &amp;amp;=\frac{1}{a}\int_{a\alpha&amp;#43;b}^{a\beta&amp;#43;b}\exp(y)dy\\ &amp;amp;=\frac{1}{a}(\exp(a\beta&amp;#43;b)-\exp(a\alpha&amp;#43;b)) \end{aligned}\] となります． ただし，最後の等号は定積分1を使いました．
定積分3 # 最後に \(\int_{\alpha}^{\beta}\exp(ax^2&amp;#43;bx&amp;#43;c)dx\ (a&amp;lt;0)\) を計算します． \(a\not=0\) より， \[ax^2&amp;#43;bx&amp;#43;c=a\left(x&amp;#43;\frac{b}{2a}\right)^2-\frac{b^2-4ac}{4a}\] です． よって， \[\begin{aligned} &amp;amp;\int_{\alpha}^{\beta}\exp(ax^2&amp;#43;bx&amp;#43;c)dx\\ &amp;amp;=\int_{\alpha}^\beta\exp\left(a\left(x&amp;#43;\frac{b}{2a}\right)^2-\frac{b^2-4ac}{4a}\right)dx\\ &amp;amp;=\exp\left(-\frac{b^2-4ac}{4a}\right)\int_{\alpha}^\beta\exp\left(a\left(x&amp;#43;\frac{b}{2a}\right)^2\right)dx \end{aligned}\] いま， \(y=x&amp;#43;b/(2a)\) とすると，</description></item><item><title>関数ポインタとその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/fp/fp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/fp/</guid><description>関数ポインタとその周辺 # 概要 # ポインタ (pointer) とは，メモリアドレスを格納するためのオブジェクトのことです． C++ では，変数のメモリアドレスはもちろん，関数のエントリーポイントとなるメモリアドレスを格納することができます．
本ページでは，Newton 法という数値解法の実装を例とし，関数ポインタについて説明します．
Newton 法とその素朴な実装 # Newton 法とは，導関数が既知である実数値関数の零点を求める数値解法のひとつです． 近似解を中心に関数を一次近似（接線で近似）し，その一次関数の零点（その接線と \(x\) 軸の交点）に近似解を更新する，という操作を繰り返すことで数値的解を求めます．
具体的にいえば，初期値を \(x_0\) としたとき，近似解の更新式は，
\[x_{k&amp;#43;1}=x_k-\frac{f(x_k)}{f&amp;#39;(x_k)},\quad k=0,1,\dots\] となります．
関数 f, 導関数 df に対して，初期点 x0 に最も近い零点を求めるための関数 Newton の素朴な実装として，以下が考えられます． ここでは，収束判定条件を \(|f(x_k)|&amp;lt;\epsilon\) \((\epsilon&amp;gt;0)\) とし， 最大反復回数 loop_max を超えたら収束しなかった旨のエラーを返すようにしています．
#include &amp;lt;cmath&amp;gt; #include &amp;lt;exception&amp;gt; #include &amp;lt;iostream&amp;gt; double f(double x) { return x*x - 2; } double df(double x) { return 2*x; } double Newton(double x0, double eps=1.0e-10, std::size_t loop_max=1024) { double x = x0; for (std::size_t i = 0; i &amp;lt; loop_max; i++) { x -= f(x) / df(x); if (std::abs(f(x)) &amp;lt; eps) { return x; } } throw std::runtime_error(&amp;#34;Not convergence.</description></item><item><title>メンバ関数ポインタとその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/fp/mfp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/mfp/</guid><description>メンバ関数ポインタとその周辺 # 概要 # ポインタ (pointer) とは，メモリアドレスを格納するためのオブジェクトのことで，関数のエントリーポイントとなるメモリアドレスを格納できます（関数ポインタ）．
前節は，関数ポインタを利用して，関数を引数にとる関数が実現できることを確認しました． 本ページでは，関数がクラスのメンバ関数の場合にどうなるかについて説明します．
クラス定義とオブジェクト指向に基づく通常の対応 # 前節の関数を多項式関数に限定します． そのため，多項式関数を表すクラス Polynomial を以下のように用意したとします．
#include &amp;lt;initializer_list&amp;gt; #include &amp;lt;vector&amp;gt; /** * @brief 多項式関数を表すクラス． * * 例えば f(x) = x^2 - 2 の表現と f(1.0) の計算は以下のようにできる． * * Polynomial f = { -2, 0, 1 }; // x^2 - 2 = -2 + 0x + 1x^2 * std::cout &amp;lt;&amp;lt; f.Eval(1.0) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; // -1.0 (=f(1.0)) */ class Polynomial { public: Polynomial(std::initializer_list&amp;lt;double&amp;gt; init) : coeffs_(init.</description></item><item><title>std::function とその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/fp/stdfunc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/stdfunc/</guid><description>std::function とその周辺 # 概要 # 前節までは，関数ポインタやメンバ関数ポインタについて説明しました． 本ページでは，標準ライブラリ std::function を利用する方法について説明します．
実用上は std::function を使う方法で十分と思います．
std::function について # functional ヘッダを include すると，std::function が利用できます． std::function の定義は以下のとおりです [1]． テンプレートクラスですが，テンプレートの特殊化によって，関数型のみが受け付けられるようになっています．
template &amp;lt;class&amp;gt; class function; /* undefined */ template &amp;lt;class R, class... Args&amp;gt; class function&amp;lt;R(Args...)&amp;gt;; まず，Args... は可変テンプレート引数の型を表します． よって，R(Args...) は 戻り値の型が R で，引数の型が Args... である関数の型です． したがって，Newton 関数を以下のように定義しておけば，f, df は関数を渡せます．
#include &amp;lt;cmath&amp;gt; #include &amp;lt;functional&amp;gt; using func_t = std::function&amp;lt;double(double)&amp;gt;; double Newton(func_t f, func_t df, double x0, double eps=1.0e-10, std::size_t loop_max=1024) { double x = x0; for (std::size_t i = 0; i &amp;lt; loop_max; i++) { x -= f(x) / df(x); if (std::abs(f(x)) &amp;lt; eps) { return x; } } throw std::runtime_error(&amp;#34;Not convergence.</description></item><item><title>関数への参照</title><link>https://htakeuchi0.github.io/docs/cpp/fp/fref/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/fref/</guid><description>関数への参照 # 概要 # 前節までで，関数ポインタとその周辺事項について説明しました． 本ページでは，関数への参照型について説明します．
関数ポインタ # 戻り値の型が T, 第 \(k\) 番目の引数の型が Sk である関数への関数ポインタ型は，
using fp_t = T (*)(S1, S2,..., Sn); または，
using f_t = T(S1, S2,..., Sn); using fp_t = f_t*; として定義できるのでした．
ここで，
using fref_t = T (&amp;amp;)(S1, S2,..., Sn); または，
using f_t = T(S1, S2,..., Sn); using fref_t = f_t&amp;amp;; とすると，関数への参照型 をつくることができます．
つまり，下記のコードをコンパイルして実行することができます．
#include &amp;lt;cmath&amp;gt; #include &amp;lt;exception&amp;gt; #include &amp;lt;iostream&amp;gt; using fref_t = double (&amp;amp;)(double); double Newton(fref_t f, fref_t df, double x0, double eps=1.</description></item></channel></rss>