<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ホームページ on htakeuchi0 のノート</title><link>https://htakeuchi0.github.io/</link><description>Recent content in ホームページ on htakeuchi0 のノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Thu, 11 Aug 2022 12:18:39 +0900</lastBuildDate><atom:link href="https://htakeuchi0.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>2023 - 実装改良編</title><link>https://htakeuchi0.github.io/docs/math/year2023/year2023_2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/year2023/year2023_2/</guid><description>2023 - 実装改良編 # 概要 # 前ページでは，
\[2023=(2&amp;#43;0&amp;#43;2&amp;#43;3)(2^2&amp;#43;0^2&amp;#43;2^2&amp;#43;3^2)^2\] であることに着目して，以下の問題を解いたのでした．
Problem 1. 整数 \(x=\sum_{j=0}^{n-1}a_j10^j\) \((0\le a_j\le 9,j=0,1,\dots,n-1)\) に対して， \[ \prod_{k=1}^K\sum_{j=0}^{n-1}a_j^{i_k}=x \] を満たす整数 \(K\ge1\), \(1\le i_1\le\cdots\le i_K\) が存在するかを判定せよ．存在する場合はこの方程式を満たす \((i_1,i_2,\dots,i_K)\) をひとつ求めよ． 本ページでは，そこで解説した解法を改良する方法を説明します． その後，改良前後で実行時間を比較します．ただし，結果はほとんど変わりませんでした．
実装改良 # 前ページで解説した解法は以下のとおりでした1．
Algorithm 2. \(\mathtt{Solve}(a, x, i)\) の擬似コードを以下で定める．ただし，\((a_1,\dots,a_n)\in\mathbb{N}^n,(b_1,\dots,b_m)\in\mathbb{N}^m\) に対して，\(\mathtt{append}(a,b)=(a_1,\dots,a_n,b_1,\dots,b_m)\in\mathbb{N}^{n+m}\) とする．
Input: \(a\in\mathbb{N}^n,x\in\mathbb{N},i\in\mathbb{N}\) Output: \(\prod_{k=1}^K\sum_{j=0}^{n-1}a_j^{i_k}=x,i\le i_1\le\dots\le i_K\) を満たす \((i_1,i_2,\dots,i_K)\) if \(\max(a)\le1\) then if \(i&amp;gt;1\) then return \(\emptyset\) if \(\sum_{j=0}^{n-1}a_j=x\) then return \((1)\) else return \(\emptyset\) end if for \(i&amp;rsquo;=i,i+1,\dots\) do \(y\leftarrow\sum_{j=0}^{n-1}a_j^{i&amp;rsquo;}\) if \(y&amp;gt;x\) then return \(\emptyset\) if \(y=x\) then return \((i&amp;rsquo;)\) if \(y\mid x\) then \(L\leftarrow\mathtt{Solve}(a,x/y,i&amp;rsquo;)\) if \(L=\emptyset\) then return \(\emptyset\) else return \(\mathtt{append}((i&amp;rsquo;),L)\) end if end for このアルゴリズムは，11行目によって再帰処理になっていますが， 再帰させずに，単に \(x\) を \(x/y\) に置き換えて処理を継続させることができます． この場合，再帰処理用に用意していた第3引数の \(i\) が不要になります．</description></item><item><title>Makefile プロジェクト</title><link>https://htakeuchi0.github.io/docs/cpp/env/make/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/env/make/</guid><description>Makefile プロジェクト # 概要 # 本ページでは，Makefile を使ったプロジェクトのディレクトリ構成の例を説明します．
cpp_env_sample ディレクトリ以下にソースコードなどを配置することとします．
Github リポジトリ # 本ページで説明するディレクトリ構成のプロジェクトは，以下の Github リポジトリ [1] として公開しています．
https://github.com/htakeuchi0/cpp_env_sample
本ページは CC BY-ND 4.0 のもとで提供していますが，このリポジトリはMITライセンスで公開しています．
動作環境 # 本ページで説明するものは，以下の環境で動作するものです．
OS: Linux (Ubuntu 18.04.5 LTS)
コンパイラ: g++ (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0 OS: Linux (Ubuntu 20.04.1 LTS)
コンパイラ: g++ (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0 単体試験，カバレッジ計測，ドキュメント生成に，それぞれ以下を利用するものとします．
Google Test [2] LCOV [3] Doxygen [4] ディレクトリ構成 # ディレクトリ構成の例は以下の通りです．
|- cpp_env_sample/ |- Doxyfile - doxygen設定ファイル |- LICENSE - ライセンスファイル |- Makefile - makeファイル |- README.</description></item><item><title>サイコロを繰り返し投げる試行の確率モデル</title><link>https://htakeuchi0.github.io/docs/math/stat/dice/dice_basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/stat/dice/dice_basic/</guid><description>サイコロを繰り返し投げる試行の確率モデル # 概要 # 本ページでは，サイコロを繰り返し投げる試行の確率モデルを定義します．
確率の定義 # 確率の定義は以下の通りです．
Definition 1.
\(X\) を集合とする．\(\mathfrak{F}\subset2^X\) が \(X\) の完全加法族であるとは，次の1&amp;ndash;3を満たすことである．ただし，\(A^c=X-A=\{x\in X\mid x\notin a\}\), \(2^X=\{A\mid A\subset X\}\) とする． \(\emptyset\in\mathfrak{F}\), \(A\in\mathfrak{F}\) ならば \(A^c\in\mathfrak{F}\), 任意の \(i\in\mathbb{N}\) について \(A_i\in\mathfrak{F}\) ならば \(\bigcup_{i=1}^{\infty}A_i\in\mathfrak{F}\). \(\Omega\) を集合とし，\(\mathfrak{F}\) を \(\Omega\) の完全加法族とする．\((\Omega,\mathfrak{F})\) を標本空間, \(\mathfrak{F}\) の点を事象，\(\Omega\) の点を標本点という． \(\Omega\) を集合とし，\(\mathfrak{F}\) を \(\Omega\) の完全加法族とする．関数 \(P:\mathfrak{F}\to\mathbb{R}\) が次の1&amp;ndash;3を満たすとき，関数 \(P\) を確率という．ただし，集合 \(A_1,A_2,\dots\) が互いに素とは，どの \(i,j\ (i\neq j)\) についても \(A_i\cap A_j=\emptyset\) であることをいい，\(A_1,A_2,\dots\) が互いに素であるとき，\(\bigcup_{i=1}^{\infty}A_i\) を \(\sum_{i=1}^{\infty}A_i\) と表す． \(A\in\mathfrak{F}\) ならば \(P(A)\ge0\), \(P(\Omega)=1\), \(A_1,A_2,\dots\in\mathfrak{F}\) が互いに素ならば，\(P(\sum_{i=1}^{\infty}A_i)=\sum_{i=1}^{\infty}P(A_i)\). \(\Omega\) を集合とし，\(\mathfrak{F}\) を \(\Omega\) の完全加法族とする．関数 \(P:\mathfrak{F}\to\mathbb{R}\) を確率とする．このとき，\((\Omega,\mathfrak{F},P)\) を確率空間という． 偏りのないサイコロを1回だけ投げる試行の確率モデル # まずは，偏りのないサイコロを1回だけ投げる試行の確率モデルを考えます．</description></item><item><title>プロジェクトマネジメント知識体系 (PMBOK) ガイドに関するノート</title><link>https://htakeuchi0.github.io/docs/others/pmbok/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/others/pmbok/</guid><description>プロジェクトマネジメント知識体系 (PMBOK) ガイドに関するノート # 概要 # 本ページでは，プロジェクトマネジメント協会 (PMI) が発行するプロジェクトマネジメント知識体系 (PMBOK) ガイドの第6版日本語版 [1]，第7版日本語版 [2] の違いについてまとめます．
はじめに # プロジェクトマネジメントに関する知識を体系化したものとして，プロジェクトマネジメント協会 (PMI) が発行する プロジェクトマネジメント知識体系 (PMBOK) ガイドが広く知られています．
近年 (2022年11月)， PMI 日本支部より，PMBOK ガイド第7版の日本語版 [2] が刊行されました．
本ページでは，PMBOK ガイド第6版日本語版 [1]，第7版日本語版 [2] の違いを中心に，それら概要をまとめます．
第6版・第7版の違い # 本節では，第6版日本語版・第7版日本語版（以下，単に第6版，第7版と呼ぶ）の違いについて述べます． この違いを明確にする目的で，第6版，第7版の概要をまとめます．
まず，第6版の概要は以下のとおりです．
PMBOK ガイドはプロジェクトマネジメント標準に基づきまたこれを含む． PMBOK ガイドおよびプロジェクトマネジメント標準は規律的実務慣行でなく，模範的実務慣行に基づく． PMBOK ガイドが述べるのは知識体系であり方法論ではない． プロジェクトマネジメント標準は特定のプロセスまたは実務慣行の実施を要求するものではない． プロジェクト・ライフサイクルは，プロジェクトマネジメント・プロセス（以下，プロセス）を実施することでマネジメントされる． プロセスはインプットがあり，ツールや技法の適用を経てアウトプットを生成するものである (ITTO)． プロセスは5個のプロジェクトマネジメント・プロセス群（以下，プロセス群）に分類される． プロセスは10個の知識エリアにも分類される． 知識エリアとは，知識に対する要求事項によって定義されたものである． プロセスは次の事項を通して，一貫した予測可能な実務慣行を可能とする1． 文書化できる． プロセスに対するパフォーマンスを評価できる． 効率を最大化し，脅威を最小化するようにプロセスを改善できる． PMBOK ガイドの後にプロジェクトマネジメント標準を置く構成とした． 次に，第7版の（特に第6版との差分に着目した）概要は以下のとおりです．
成果物でなく意図した成果をより重視するため，原理・原則ベースの標準に移行した． プロセスベースの標準は本質的に規範的である． 過去のプロセスベース指向では価値実現の全貌を示すための方法として維持できない． 過去の版のプロセスベース・アプローチとの整合を無効にする内容は存在しない． プロジェクトマネジメント標準の価値実現の全体観に始まり，その後 PMBOK ガイドの内容表現へと続く構成とした． 10個の知識エリアは8個のパフォーマンス領域へ変更した． PMBOK ガイドにテーラリング2 専用の章を設けた． PMBOK ガイドに「モデル，方法，作成物」という章を設けたが，これは ITTO とのリンクが維持され拡張されるものである． 以上より，価値実現・成果に重きがおかれるようになり，より実務的慣行に基づくようにするため，第6版までのプロセスベースでなく，原理・原則ベースの標準に移行した，という趣旨が読み取れます．</description></item><item><title>指数関数の定積分</title><link>https://htakeuchi0.github.io/docs/math/exp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/exp/</guid><description>指数関数の定積分 # 概要 # 本ページでは，指数関数に関するいくつかの定積分の求め方と結果を説明します． 指数関数 \(\exp:\mathbb{R}\to\mathbb{R}\) とは， \[\exp(x)=\sum_{k=0}^n\frac{x^k}{k!}\] で定められる関数であり， \(\exp&amp;#39;(x)=\exp(x)\) が成り立つことが知られています．
本ページでは，以下の定積分の求め方と結果をまとめます．
\(\int_{\alpha}^{\beta}\exp(x)dx\) \(\int_{\alpha}^{\beta}\exp(ax&amp;#43;b)dx\quad(a\not=0)\) \(\int_{\alpha}^{\beta}\exp(ax^2&amp;#43;bx&amp;#43;c)dx\quad(a&amp;lt;0)\) ただし，以下の関数を既知とします．この関数は，相補誤差関数と呼ばれ，たとえば C++ の標準ライブラリで std::erfc として定義されています．
Definition 1. 相補誤差関数 \(\mathrm{erfc}:\mathbb{R}\to\mathbb{R}\) を以下のように定める．
\[\mathrm{erfc}(x)=\frac{2}{\sqrt{\pi}}\int_x^{\infty}\exp(-t^2)dt.\] 定積分1 # まず， \(\int_{\alpha}^{\beta}\exp(x)dx\) を計算します． これは， \(\exp&amp;#39;(x)=\exp(x)\) なので， \[\int_{\alpha}^{\beta}\exp(x)dx=\exp(\beta)-\exp(\alpha)\] です．
定積分2 # 次に， \(\int_{\alpha}^{\beta}\exp(ax&amp;#43;b)dx\ (a\not=0)\) を計算します． これには，[1, 定理5.6] を利用します．
Theorem 2. 関数 \(f,\phi\) が次の 1&amp;ndash;4 を満たすと仮定する．
\(f(x)\) は区間 \(I=[a,b]\) で連続， \(\phi(t)\) は区間 \(J=[\alpha,\beta]\) で微分可能， \(\phi'(t)\) は \(J\) で有界可積分（例えば連続）， \(\phi(J)\subset I\), \(\phi(\alpha)=a\), \(\phi(\beta)=b\). このとき，次の等式が成り立つ．</description></item><item><title>空のサイトの生成</title><link>https://htakeuchi0.github.io/docs/hugo/base/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/hugo/base/</guid><description>空のサイトの生成 # 概要 # 本ページでは，Hugo による Web サイト作成の最初のステップについて説明します． 具体的には，ローカルに空のサイトが生成できるところまで説明します．
インストール # Hugo の Quick Start に従い，Hugo をインストールします．
作者の作成環境は Linux OS 64bit (Ubuntu 18.04.6 LTS) なので，Hugo のインストールページ を参考に，以下のコマンドを実行します．
$ snap install hugo --channel=extended デスクトップ環境なので，認証のためのダイアログが表示され，パスワードを入力して認証をクリックしました．
以下のコマンドでインストールが成功したかを確認できます．
$ hugo version hugo v0.101.0-9f74196ce611cdf6d355bfb99fd8eba5c68ef7f8+extended linux/amd64 BuildDate=2022-06-28T10:02:18Z VendorInfo=snap サイトの生成 # 以下のコマンドを実行します．
$ hugo new site htakeuchi0-notebook テーマの追加 # 本サイトでは，Book テーマを利用しています． 当該テーマの README にしたがって，以下のコマンドを実行します．
$ cd htakeuchi0-notebook $ git init $ git branch -M main $ git submodule add https://github.</description></item><item><title>配列へのポインタとその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/arrp/arrp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/arrp/arrp/</guid><description>配列へのポインタとその周辺 # 概要 # 配列とは，同じ型の複数の変数をまとめて扱うためのデータ構造です．
ポインタ (pointer) とは，メモリアドレスを格納するためのオブジェクトのことです． C++ では，変数のメモリアドレスはもちろん，関数のエントリーポイントとなるメモリアドレスを格納することができます．
関数ポインタ の節では，関数へのポインタについて説明しました．本ページでは，C++における配列とポインタの関係を説明した後，配列型へのポインタ型について説明します．ここで，配列型へのポインタ型とは，そのポインタ型の変数に対して * 演算子で値を得ると，要素ではなく，配列そのものが得られるようなポインタ型を指すものとします．
配列とポインタ # 配列とは，同じ型の複数の変数をまとめて扱うためのデータ構造です．例えば，int 型の変数を10個まとめて扱うための配列は以下のように宣言できます．
int arr[10]; 使いかたは以下のとおりです．
#include &amp;lt;iostream&amp;gt; int main() { int arr[10]; for (int i = 0; i &amp;lt; 10; i++) { arr[i] = i * 2; } std::cout &amp;lt;&amp;lt; arr[0] &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; // 0 std::cout &amp;lt;&amp;lt; arr[1] &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; // 2 std::cout &amp;lt;&amp;lt; arr[2] &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; // 4 return 0; } 配列変数は，変数からその要素数を取得する方法は，言語仕様としては提供されていません．ただし，C言語の時代から，配列変数の要素数を取得する方法として，以下の方法が広く知られています．</description></item><item><title>関数ポインタとその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/fp/fp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/fp/</guid><description>関数ポインタとその周辺 # 概要 # ポインタ (pointer) とは，メモリアドレスを格納するためのオブジェクトのことです． C++ では，変数のメモリアドレスはもちろん，関数のエントリーポイントとなるメモリアドレスを格納することができます．
本ページでは，Newton 法という数値解法の実装を例とし，関数ポインタについて説明します．
Newton 法とその素朴な実装 # Newton 法とは，導関数が既知である実数値関数の零点を求める数値解法のひとつです． 近似解を中心に関数を一次近似（接線で近似）し，その一次関数の零点（その接線と \(x\) 軸の交点）に近似解を更新する，という操作を繰り返すことで数値的解を求めます．
具体的にいえば，初期値を \(x_0\) としたとき，近似解の更新式は，
\[x_{k&amp;#43;1}=x_k-\frac{f(x_k)}{f&amp;#39;(x_k)},\quad k=0,1,\dots\] となります．
関数 f, 導関数 df に対して，初期点 x0 に最も近い零点を求めるための関数 Newton の素朴な実装として，以下が考えられます． ここでは，収束判定条件を \(|f(x_k)|&amp;lt;\epsilon\) \((\epsilon&amp;gt;0)\) とし， 最大反復回数 loop_max を超えたら収束しなかった旨のエラーを返すようにしています．
#include &amp;lt;cmath&amp;gt; #include &amp;lt;exception&amp;gt; #include &amp;lt;iostream&amp;gt; double f(double x) { return x*x - 2; } double df(double x) { return 2*x; } double Newton(double x0, double eps=1.0e-10, std::size_t loop_max=1024) { double x = x0; for (std::size_t i = 0; i &amp;lt; loop_max; i++) { x -= f(x) / df(x); if (std::abs(f(x)) &amp;lt; eps) { return x; } } throw std::runtime_error(&amp;#34;Convergence error: This method did not converge.</description></item><item><title>autoconf プロジェクト (1)</title><link>https://htakeuchi0.github.io/docs/cpp/env/autoconf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/env/autoconf/</guid><description>autoconf プロジェクト (1) # 概要 # 前ページでは，Makefile プロジェクトの例について説明しました．本ページでは，autoconf を使った Makefile の自動生成について説明します．
本ページでは，わかりやすさを優先し，やや不自然な箇所がありますが，できるだけ簡単な準備で autoconf による Makefile 生成と，make の実行を試みます．
準備 # Makefile プロジェクト のリポジトリからスタートします． 初期状態のディレクトリ構成は以下のとおりです．
|- cpp_env_sample/ |- Doxyfile - doxygen設定ファイル |- LICENSE - ライセンスファイル |- Makefile - makeファイル |- README.md - READMEファイル |- include/ - ヘッダファイル | |- cpp_env_sample/ | |- example.h | |- main/ - メインファイル | |- main.cc | |- scripts/ - 環境構築用スクリプト | |- install_doxygen.sh | |- install_gtest.</description></item><item><title>サイコロをN回投げたときちょうど6回に1回の割合で1の目が出る確率</title><link>https://htakeuchi0.github.io/docs/math/stat/dice/dice_ratio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/stat/dice/dice_ratio/</guid><description>サイコロをN回投げたときちょうど6回に1回の割合で1の目が出る確率 # 概要 # 前ページでは，サイコロを繰り返し投げる試行の確率モデルを定義しました．
本ページからは，サイコロを繰り返し投げると，およそ6回に1回程度の割合で1の目が出ることを確認します．
しかし，そもそもこれはどのように確認したらよいのでしょうか．
本ページではひとまず，ちょうど 6回に1回の割合で1の目が出る確率を計算してみます．
まず，サイコロを \(N\) 回投げたとき \(k\) 回だけ1の目が出る確率を求めます．その後，サイコロを繰り返し投げたとき，ちょうど 6回に1回の割合で1の目が出る確率を求めます．
サイコロをN回投げたときk回だけ1の目が出る確率 # いま，確率空間 \((\Omega_N,\mathfrak{F}_N,P_N)\) を考えます． \(A_k=\{(\omega^j)\in\Omega_N\mid |\{j\mid \omega^j=\omega_1\}|=k\}\) とすると， \(A_k\) は \(N\) 回サイコロをなげて \(k\) 回だけ1の目が出た事象を表します．
\((\omega^j)\in A_k\) とすると， \(\omega^1,\omega^2,\dots,\omega^N\) のうち \(k\) 個が \(\omega_1\) ですが，これは \(N\) 個から \(k\) 個を選ぶ選び方を考えればよいので， \(\binom{N}{k}=N!/(k!(N-k)!)\) 個あります．
このとき，ある \(\{i_1,i_2,\dots,i_k\}\subset\{1,2,\dots,N\}\) について， \(k\) 個の要素 \(\omega^{i_j}\,(j=1,2,\dots,k)\) は \(\omega_1\) の1通りの値しかとれませんが，それ以外の \(N-k\) 個の要素は \(\omega_2,\omega_3,\dots,\omega_6\) の5通りの値をとれます．
したがって， \(|A_k|=\binom{N}{k}5^{N-k}\) とわかります．さらに， \(|\Omega_N|=6^N\) なので， \(P_N(A_k)=\binom{N}{k}5^{N-k}/6^N\) となります．
よって，以下のことがいえそうです．
Proposition 1. 偏りのないサイコロを \(N\) 回投げて \(k\) 回だけ1の目が出る確率は</description></item><item><title>ページの追加とサイトの設定</title><link>https://htakeuchi0.github.io/docs/hugo/set_config/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/hugo/set_config/</guid><description>ページの追加とサイトの設定 # 概要 # 本ページでは，Hugo による Web サイト作成における，ページの追加とサイトの設定に関する部分を説明します．
ホームページの作成 # まずは，サイト全体のホームページ（トップページ）を作成します． 以下のコマンドを実行すると，ホームページが作成されます．
$ hugo new _index.md content/_index.md が生成されているので，それを以下のように書き換えます． タイトルと適当な小見出しを作成しており，メニューからリンクを張るため，免責事項とプライバシーポリシーは，別名でアンカーを作成しています．
--- title: &amp;#34;ホームページ&amp;#34; date: 2022-08-11T12:18:39+09:00 draft: true --- # htakeuchi0 のノート ## 概要 ## 免責事項 {#disclaimer} ## プライバシーポリシー {#privacy_policy} ## 作者について ## お問い合わせ 次に，設定ファイル confing.toml を以下のようにします．
baseURL = &amp;#39;https://htakeuchi0.github.io/&amp;#39; languageCode = &amp;#39;ja-jp&amp;#39; title = &amp;#39;htakeuchi0 のノート&amp;#39; theme = &amp;#39;hugo-book&amp;#39; enableGitInfo = true [params] BookTheme = &amp;#39;auto&amp;#39; BookRepo = &amp;#39;https://github.com/htakeuchi0/htakeuchi0.github.io-sources&amp;#39; BookSearch = false [menu] [[menu.</description></item><item><title>メンバ関数ポインタとその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/fp/mfp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/mfp/</guid><description>メンバ関数ポインタとその周辺 # 概要 # ポインタ (pointer) とは，メモリアドレスを格納するためのオブジェクトのことで，関数のエントリーポイントとなるメモリアドレスを格納できます（関数ポインタ）．
前ページでは，関数ポインタを利用して，関数を引数にとる関数が実現できることを確認しました． 本ページでは，関数がクラスのメンバ関数の場合にどうなるかについて説明します．
クラス定義とオブジェクト指向に基づく通常の対応 # 前節の関数を多項式関数に限定します． そのため，多項式関数を表すクラス Polynomial を以下のように用意したとします．
#include &amp;lt;initializer_list&amp;gt; #include &amp;lt;vector&amp;gt; /** * @brief 多項式関数を表すクラス． * * 例えば f(x) = x^2 - 2 の表現と f(1.0) の計算は以下のようにできる． * * Polynomial f = { -2, 0, 1 }; // x^2 - 2 = -2 + 0x + 1x^2 * std::cout &amp;lt;&amp;lt; f.Eval(1.0) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; // -1.0 (=f(1.0)) */ class Polynomial { public: Polynomial(std::initializer_list&amp;lt;double&amp;gt; init) : coeffs_(init.</description></item><item><title>指数関数の定積分：正規分布の累積分布関数の計算への応用</title><link>https://htakeuchi0.github.io/docs/math/exp_normal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/exp_normal/</guid><description>指数関数の定積分：正規分布の累積分布関数の計算への応用 # 概要 # 指数関数の定積分 のページでは，指数関数に関するいくつかの定積分の表示について説明しました．本ページでは，その応用として，正規分布の累積分布関数の計算への応用について説明します．
例えば，C++17 では，標準ライブラリに std::erfc 関数（相補誤差関数）がありますが，正規分布の累積分布関数を直接計算する関数は提供されていません．
しかし，相補誤差関数と正規分布の累積分布関数はスケールが異なるだけなので，std::erfc 関数があれば，正規分布の累積分布関数は計算できます．
そこで，本ページでは，指数関数の定積分 の結果を用いて，相補誤差関数と正規分布の累積分布関数の具体的な関係式を導出します．
正規分布 # 正規分布 とは，連続型確率変数のしたがう確率分布のひとつで，様々な場面で用いられます．
平均 \(\mu\) , 分散 \(\sigma^2\) の正規分布の 確率密度関数 は， \[f_X(x)=\frac{1}{\sqrt{2\pi\sigma^2}}\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)\] と表されます． ここで， \[F_X(x)=\int_{-\infty}^xf_X(x)dx\] とおくと， \(F_X(x)\) は，正規分布に従う確率変数 \(X\) が \(x\) 以下である確率を表します． 一般に，確率密度関数 \(f_X\) を用いて上記の \(F_X\) のように定義される関数を 累積分布関数 と呼びます．
正規分布の累積分布関数と誤差関数 # いま， \[-\frac{(x-\mu)^2}{2\sigma^2}=-\frac{1}{2\sigma^2}x^2&amp;#43;\frac{\mu}{\sigma^2}x-\frac{\mu^2}{2\sigma^2}\] なので， \[\begin{aligned} &amp;amp;a=-\frac{1}{2\sigma^2},\\ &amp;amp;b=\frac{\mu}{\sigma^2},\\ &amp;amp;c=-\frac{\mu^2}{2\sigma^2} \end{aligned}\] として，指数関数の定積分の定積分3を適用すると， \[\begin{aligned} &amp;amp;\frac{\sqrt{\pi}}{2\sqrt{-a}}=\frac{\sqrt{\pi}}{2\sqrt{1/(2\sigma^2)}} =\frac{\sqrt{\pi}\sqrt{\sigma^2}}{\sqrt{2}},\\ &amp;amp;\frac{b^2-4ac}{4a}=\frac{b^2}{4a}-c=\frac{\mu^2/\sigma^4}{-2/\sigma^2}-\left(-\frac{\mu^2}{2\sigma^2}\right)=0\\ &amp;amp;\frac{b}{2a} =\frac{\mu/\sigma^2}{-1/\sigma^2} =-\mu \end{aligned}\] より， \[\begin{aligned} &amp;amp;\int_{\alpha}^{\beta}\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)dx\\ &amp;amp;=\frac{\sqrt{\pi}\sqrt{\sigma^2}}{\sqrt{2}}\\ &amp;amp;\quad\times\left(\mathrm{erfc}\left(\frac{1}{\sqrt{2\sigma^2}}(\alpha-\mu)\right)-\mathrm{erfc}\left(\frac{1}{\sqrt{2\sigma^2}}(\beta-\mu)\right)\right) \end{aligned}\] となります．特に， \(\beta=x\) , \(\alpha\to-\infty\) のとき， \[\begin{aligned} &amp;amp;\int_{-\infty}^x\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)dx\\ &amp;amp;=\frac{\sqrt{\pi}\sqrt{\sigma^2}}{\sqrt{2}}\left(2-\mathrm{erfc}\left(\frac{1}{\sqrt{2\sigma^2}}(x-\mu)\right)\right) \end{aligned}\] です．</description></item><item><title>配列への参照</title><link>https://htakeuchi0.github.io/docs/cpp/arrp/arr_ref/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/arrp/arr_ref/</guid><description>配列への参照 # 概要 # 前ページまでで，配列へのポインタ，特に配列型へのポインタ型について説明しました．ここで，配列型へのポインタ型とは，そのポインタ型の変数に対して * 演算子で値を得ると，要素ではなく，配列そのものが得られるようなポインタ型を指すものとします．本ページでは，配列型への参照型について説明します．
配列型への参照型 # クラス T の要素数 N の配列型へのポインタ変数 p_arr の宣言は，
using p_arr_t = T (*)[N]; または，
using arr_t = T[N]; using p_arr_t = arr_t *; として定義できるのでした．
ここで，
using arr_ref_t = T (&amp;amp;)[N]; または，
using arr_t = T[N]; using arr_ref_t = arr_t&amp;amp;; とすると，配列型への参照型 をつくることができます．
これを利用すると，前ページで説明した ArraySize 関数テンプレートを参照型で定義できるため，呼び出し側で &amp;amp; をつけずに利用できるようになります．
具体的には，以下のようにできます．
#include &amp;lt;cstddef&amp;gt; #include &amp;lt;iostream&amp;gt; template &amp;lt;class T, std::size_t N&amp;gt; std::size_t ArraySize(T (&amp;amp;)[N]) { return N; } int main() { int arr[100]; std::cout &amp;lt;&amp;lt; ArraySize(arr) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; // 100 double arr2[1024]; std::cout &amp;lt;&amp;lt; ArraySize(arr2) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; // 1024 return 0; } まとめ # 本ページでは，配列型への参照型が定義できることを説明しました．配列型へのポインタ型でなく，配列型への参照型を利用すると，前ページの ArraySize 関数テンプレートの呼び出し方を，少しだけ簡単にできます．</description></item><item><title>autoconf プロジェクト (2)</title><link>https://htakeuchi0.github.io/docs/cpp/env/autoconf2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/env/autoconf2/</guid><description>autoconf プロジェクト (2) # 概要 # 前ページでは，autoconf を使った Makefile の自動生成について説明しましたが，Makefile.am は main と test ディレクトリだけに配置し，subdir-objects オプションを使いました．
autoconf では，各ディレクトリに Makefile.am を配置するのが通常と思いますので，その方針で設定をし直します．
ただし，ディレクトリをまたいだソースコードをまとめてビルドできないので， srcディレクトリ以下はライブラリとしてビルドし，main, test ではそのライブラリをリンクしてビルドします．
その場合は，Libtool を利用したライブラリ生成が必要になるので，順を追って説明するために，前ページではそのようにしませんでした．
本ページでは，Libtool を利用して，各ディレクトリに Makefile.am を配置して Makefile を生成する方法を説明します．
準備 # 今回も Makefile プロジェクト のリポジトリからスタートします． 初期状態のディレクトリ構成は以下のとおりです．
|- cpp_env_sample/ |- Doxyfile - doxygen設定ファイル |- LICENSE - ライセンスファイル |- Makefile - makeファイル |- README.md - READMEファイル |- include/ - ヘッダファイル | |- cpp_env_sample/ | |- example.h | |- main/ - メインファイル | |- main.</description></item><item><title>std::array について</title><link>https://htakeuchi0.github.io/docs/cpp/arrp/stdarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/arrp/stdarray/</guid><description>std::array について # 概要 # 前ページまでで，配列型へのポインタ型や参照型について説明しました．一方で，標準ライブラリには std::array 構造体テンプレートがあり，通常の配列のパフォーマンスを保ったまま，サイズの取得などの付随的な機能を利用できます．
std::array について # array ヘッダを include すると，std::array が利用できます． std::array の定義は以下のとおりです [1]．
namespace std { template &amp;lt;class T, std::size_t N&amp;gt; struct array; } // namespace std std::array は通常の配列と同等のパフォーマンスで利用できるとされています．通常の配列と異なり，以下のように，変数から配列のサイズが取得できます．よって，std::array を使う限り，前ページで定義した ArraySize は不要です．
#include &amp;lt;array&amp;gt; #include &amp;lt;iostream&amp;gt; int main() { std::array&amp;lt;int, 3&amp;gt; a; std::cout &amp;lt;&amp;lt; a.size() &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; // 3 return 0; } まとめ # 本ページでは，std::array について説明しました．std::array を使えば，配列から要素数を取得できます．よって，std::array を使う限り，前ページで定義した ArraySize 関数テンプレートは不要になります．
参考文献 # [1] cppreference.</description></item><item><title>std::function とその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/fp/stdfunc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/stdfunc/</guid><description>std::function とその周辺 # 概要 # 前ページまでは，関数ポインタやメンバ関数ポインタについて説明しました．本ページでは，標準ライブラリ std::function を利用する方法について説明します．
実用上は std::function を使う方法で十分と思います．
std::function について # functional ヘッダを include すると，std::function が利用できます． std::function の定義は以下のとおりです [1]． テンプレートクラスですが，テンプレートの特殊化によって，関数型のみが受け付けられるようになっています．
template &amp;lt;class&amp;gt; class function; /* undefined */ template &amp;lt;class R, class... Args&amp;gt; class function&amp;lt;R(Args...)&amp;gt;; まず，Args... は可変テンプレート引数の型を表します． よって，R(Args...) は 戻り値の型が R で，引数の型が Args... である関数の型です． したがって，Newton 関数を以下のように定義しておけば，f, df は関数を渡せます．
#include &amp;lt;cmath&amp;gt; #include &amp;lt;functional&amp;gt; using func_t = std::function&amp;lt;double(double)&amp;gt;; double Newton(func_t f, func_t df, double x0, double eps=1.0e-10, std::size_t loop_max=1024) { double x = x0; for (std::size_t i = 0; i &amp;lt; loop_max; i++) { x -= f(x) / df(x); if (std::abs(f(x)) &amp;lt; eps) { return x; } } throw std::runtime_error(&amp;#34;Convergence error: This method did not converge.</description></item><item><title>サイコロをN回投げたときおよそ6回に1回程度の割合で1の目が出ることの確認</title><link>https://htakeuchi0.github.io/docs/math/stat/dice/dice_approx_ratio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/stat/dice/dice_approx_ratio/</guid><description>サイコロをN回投げたときおよそ6回に1回程度の割合で1の目が出ることの確認 # 概要 # サイコロを繰り返し投げると，およそ6回に1回程度の割合で1の目が出ることを確認したいと思いますが，ちょうど6回に1回の割合で出るわけではないことがわかりました．
そこで，本ページでは，およそ6回に1回程度の割合で出ることを確認する方法を考えます．
いま， \(p(N,k)=\binom{N}{k}5^{N-k}/6^N\) とします．
このとき，以下の方針が考えられます．
\(p(N,k)\) が最大となる \(k\) が，およそ \(N/6\) であることを確認する． サイコロを繰り返し投げると，平均的に \(N/6\) 程度の回数だけ1の目が出ることを確認する． 1は， \(N\) を固定したとき，1の目が出る回数として最もあり得るのがおよそ \(N/6\) のときであることを確認する方針です．
2は，サイコロを \(N\) 投げる試行自体を繰り返すと，試行ごとにばらつきがあるが，平均的には \(N/6\) 回程度1の目が出ることを確認する方針です．
確率が最大となる1の目の出る回数がN/6程度であることの確認 # まず， \(p(N,k)\) を数値的に計算してみます． \(N=10,100,1000\) の場合を計算しますが，値が小さくなりすぎるので， \(\log_{10}p(N,k)\) を計算することにします．
縦軸・横軸のスケールが各グラフで異なる点に注意してください．
Figure 1. N=10の場合 Figure 2. N=100の場合 Figure 3. N=1000の場合 Figs. 1&amp;ndash;3 より， \(k=k_0\) で \(p(N,k)\) が最大になるとき， \(k&amp;lt;k_0\) の範囲では \(p(N,k)\) は大きくなり， \(k&amp;gt;k_0\) の範囲では， \(p(N,k)\) は小さくなるようです．よって，この頂点となる \(k=k_0\) が \(N/6\) 程度だとわかればよさそうです．
\(p(N,k)&amp;gt;0\) なので， \(p(N,k&amp;#43;1)/p(N,k)\) を計算すると，</description></item><item><title>公開用ファイルの生成</title><link>https://htakeuchi0.github.io/docs/hugo/genpages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/hugo/genpages/</guid><description>公開用ファイルの生成 # 概要 # 本ページでは，Hugo で作成した markdown ファイルを公開用の html ファイルにビルドして，公開する方法について説明します．
htmlファイルの生成 # 以下のコマンドを実行すると，public ディレクトリ以下に公開用ファイル一式が生成されます．
$ hugo --minify -D ページの公開 # 本サイトは，Github Pages [1] を利用してページを公開しています． 作者は，作成用ファイルと公開ファイルを 別リポジトリで管理しています．
htakeuchi0.github.io リポジトリ：公開用 htakeuchi0.github.io-sources リポジトリ：作成用 Hugo では [2] のように，同一リポジトリで別ブランチで管理する方法が説明されています．
本サイトの管理方法の場合，htakeuchi0.github.io-sources リポジトリ側で public 以下に生成されたファイルすべてを，htakeuchi0.github.io リポジトリに配置します．
あとは，[1] のとおりに設定すれば，数分でブラウザからアクセスできるようになります．
Google Search Console の設定 # Hugo では（少なくとも Book テーマでは），サイトマップ用の sitemap.xml とRSS用の index.xml が生成されているので，それぞれを Google Search Console [3] に登録するだけです．
まとめ # 本ページでは，公開ファイルを生成して，公開する方法について説明しました．
参考文献 # [1] Github, &amp;ldquo;About GitHub Pages - GitHub Docs&amp;rdquo;, https://docs.</description></item><item><title>autoconf プロジェクト (3)</title><link>https://htakeuchi0.github.io/docs/cpp/env/autoconf3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/env/autoconf3/</guid><description>autoconf プロジェクト (3) # 概要 # 前ページでは，Libtool を利用して，より自然な autoconf を使った Makefile の自動生成について説明しました．
しかし，Makefile プロジェクト と比べると以下の点が不十分です．
make clean をしても *.gcno, *.gcda のファイルが残る make check で Google Test の結果が表示されない make docs, make lcov が実行できない make lib で共有ライブラリのビルドができない 本ページでは，これらを組み込む方法を説明します．その後，&amp;ldquo;その他&amp;rdquo; として，さらに不足している設定も説明します．
make clean をしたとき *.gcno, *.gcda のファイルを消すようにする # 本節では，make clean をしたときに削除されないファイルがあることへの対処法を説明します．
本プロジェクトの場合，削除されないファイルは src/*.gcno, test/*.gcno, test/*.gcda ですが，これらファイルは make check で使っている gcov のカバレッジ計測用ファイルです．
このように &amp;ldquo;ローカルルール&amp;rdquo; で生成されたファイルを消すには，clean のローカルルールのようなものを定義してあげる必要があります．
前ページ で，プロジェクトのルートディレクトリに以下のような Makefile.am を用意しました．
SUBDIRS = include src main test ACLOCAL_AMFLAGS = -I m4 ここに以下のルールを追加します．</description></item><item><title>サイコロをN回投げたときおよそ6回に1回程度の割合で1の目が出ることの確率変数の導入による整理</title><link>https://htakeuchi0.github.io/docs/math/stat/dice/dice_randval/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/stat/dice/dice_randval/</guid><description>サイコロをN回投げたときおよそ6回に1回程度の割合で1の目が出ることの確率変数の導入による整理 # 概要 # 前ページまでで，サイコロを \(N\) 回投げるとき，次が成り立つことがわかりました．
確率が最大となる1の目の出る回数は \(N/6\) 程度である 平均的に \(N/6\) 回程度，1の目が出る しかし，もとの“およそ6回に1回程度の割合で1の目が出る”という主張に対して，平均といった概念をもちだしているなど，直接的な結果に感じません．
そこで本ページでは，確率変数を導入することで，この問題をより取り扱いやすくして，およそ6回に1回程度の割合で1の目が出ることを，より直接的に示せないかを検討します．
確率変数 # まずは，確率変数の定義について述べます．
Definition 1.
\(A\) を集合，\(\mathfrak{F}\) をその完全加法族とする．一般に，\((A,\mathfrak{F})\) を 可測空間 という．また，\((A,\mathfrak{F}),(B,\mathfrak{G})\) を可測空間とするとき，関数 \(F:A\to B\) を \(F:(A,\mathfrak{F})\to(B,\mathfrak{B})\) と表す． \((A,\mathfrak{F}),(B,\mathfrak{G})\) を可測空間とする．関数 \(F:(A,\mathfrak{F})\to (B,\mathfrak{F})\) が，任意の \(b\in B\) について \(F^{-1}(b)=\{a\in A\mid F(a)=b\}\in\mathfrak{F}\) であるとき，関数 \(F\) を可測関数と呼ぶ． \(\mathbb{R}\) の開集合全体の集合を \(\mathfrak{O}(\mathbb{R})\) と表す．\(\mathfrak{O}(\mathbb{R})\) を含む最小の完全加法族を \(\mathfrak{B}(\mathbb{R})\) と表す． \(\Omega,\mathfrak{F}\) を標本空間とする，\(X:(\Omega,\mathfrak{F})\to(\mathbb{R},\mathfrak{B}(\mathbb{R}))\) が可測関数のとき，\(X\) を確率変数という． なお，可測空間も標本空間も集合とその完全加法族の組なので，実質的には同じものですが，数理統計の文脈では，可測空間のことを標本空間と呼ぶ，という理解でよいです．また，本来は \(\mathfrak{B}(\mathbb{R})\) の存在を示す必要がありますが，ここでは認めるものとします．
\(X\) の像 \(X(\Omega)=\{x\in\mathbb{R}\mid \exists \omega\in\Omega\,(X(\omega)=x)\}\) が高々可算のとき， \(X\) は離散型確率変数と呼ばれます．
ここで， \([X=x]=\{\omega\in\Omega_N\mid X(\omega)=x\}\) とし， \(P([X=x])\) を \(P(X=x)\) と略記することにします． \([X&amp;lt;x],[X\le x],P(X&amp;lt;x),P(X\le x)\) なども同様です．</description></item><item><title>独自ショートコードの定義</title><link>https://htakeuchi0.github.io/docs/hugo/shortcode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/hugo/shortcode/</guid><description>独自ショートコードの定義 # 概要 # Hugo には，ショートコードと呼ばれるスニペットを定義・利用できる機能があります [1]．本ページでは，ショートコードの一例として，theorem-label という， \(\LaTeX\) でいう定理環境のラベル部分を生成する独自ショートコードを定義する方法について説明します．なお一般に，スニペットとは，再利用可能なソースコード断片を指す言葉です．
theorem-label ショートコード # Hugo は markdown で記事を作成できますが，markdown の簡潔に記述できる利点を損なわないよう，ショートコードと呼ばれるスニペットを定義し，利用できる機能があります．
ここでは，定理環境のラベルを生成する簡単なショートコードを作成します．ここで，定理環境とは， \(\LaTeX\) でいう定理環境のような，定理や定義を示すための文章ブロックを指すものとし，そのラベルとは &amp;ldquo;Theorem 2.3&amp;rdquo; のような文章ブロックの冒頭に書かれるラベルを指すものとします．
theorem-label ショートコードは以下の要件を満たすものとします．
&amp;ldquo;Theorem 1.&amp;rdquo; のように，定理種類名称と定理番号を太字で表示できて，ピリオドで終わること 定理種類名称はユーザが指定できること 定理番号はページごとに，定理種類名称によらず，1からはじまる連番で自動生成されること 定理番号の前に節番号などの接頭辞を任意でつけられること 定理番号の後に括弧付きコメントを任意でつけられること そこで，theorem-label ショートコードは以下のように呼び出せるものとします．
項番 呼び出し方 結果 1 {{&amp;lt; theorem-label name=&amp;quot;Theorem&amp;quot; &amp;gt;}} Theorem 1. 2 {{&amp;lt; theorem-label name=&amp;quot;Theorem&amp;quot; section=&amp;quot;5.2&amp;quot; &amp;gt;}} Theorem 5.2.2. 3 {{&amp;lt; theorem-label name=&amp;quot;Proposition&amp;quot; section=&amp;quot;3&amp;quot; comment=&amp;quot;補足&amp;quot; &amp;gt;}} Theorem 3.3 (補足). 実装例は以下のとおりです．下記ファイルを layout/shortcodes/theorem-label.html として保存します．
&amp;lt;!-- カウンタの初期化--&amp;gt; {{- if not (.</description></item><item><title>関数への参照</title><link>https://htakeuchi0.github.io/docs/cpp/fp/fref/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/fref/</guid><description>関数への参照 # 概要 # 前ページまでで，関数ポインタとその周辺事項について説明しました． 本ページでは，関数への参照型について説明します．
関数への参照型 # 戻り値の型が T, 第 \(k\) 番目の引数の型が Sk である関数への関数ポインタ型は，
using fp_t = T (*)(S1, S2,..., Sn); または，
using f_t = T(S1, S2,..., Sn); using fp_t = f_t*; として定義できるのでした．
ここで，
using fref_t = T (&amp;amp;)(S1, S2,..., Sn); または，
using f_t = T(S1, S2,..., Sn); using fref_t = f_t&amp;amp;; とすると，関数への参照型 をつくることができます．
つまり，下記のコードをコンパイルして実行することができます．
#include &amp;lt;cmath&amp;gt; #include &amp;lt;exception&amp;gt; #include &amp;lt;iostream&amp;gt; using fref_t = double (&amp;amp;)(double); double Newton(fref_t f, fref_t df, double x0, double eps=1.</description></item><item><title>autoconf プロジェクト (4)</title><link>https://htakeuchi0.github.io/docs/cpp/env/autoconf4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/env/autoconf4/</guid><description>autoconf プロジェクト (4) # 概要 # 前ページまでで，Makefile プロジェクト とほとんど同様の機能をもつ autoconf プロジェクトの作成方法を説明しました．
本ページでは，これまでの説明の総括として，autoconf プロジェクト(1) や autoconf プロジェクト (2) と同じ節構成で，Makefile プロジェクト をもとにした autoconf プロジェクトの作成手順を説明します．
Github リポジトリ # 本ページで説明するディレクトリ構成の autoconf プロジェクトは，以下の Github リポジトリ [1] として公開しています．
https://github.com/htakeuchi0/autoconf_sample
本ページは CC BY-ND 4.0 のもとで提供していますが，このリポジトリはMITライセンスで公開しています．
準備 # Makefile プロジェクト のリポジトリからスタートします． 初期状態のディレクトリ構成は以下のとおりです．
|- cpp_env_sample/ |- Doxyfile - doxygen設定ファイル |- LICENSE - ライセンスファイル |- Makefile - makeファイル |- README.md - READMEファイル |- include/ - ヘッダファイル | |- cpp_env_sample/ | |- example.</description></item><item><title>Book テーマの hint ショートコードブロック内に数式を表示する際の注意</title><link>https://htakeuchi0.github.io/docs/hugo/book_katex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/hugo/book_katex/</guid><description>Book テーマの hint ショートコードブロック内に数式を表示する際の注意 # 概要 # Book テーマ [1] では， \(\KaTeX\) を使うための katex ショートコードが用意されています [2]． また，目立たせたい情報を文書ブロックとして表示できる，hint ショートコードが用意されています [3]．
しかし，hint ショートコードブロックの中で katex ショートコードを使う場合，うまく数式が表示できないことがあります． 本ページでは，hint ショートコードブロック内で数式を表示する場合の注意について説明します．
hint ショートコードの使いかた # 公式の説明 [3] をもとに，markdown での記述例と，出力結果を説明します．hint ショートコードは第1引数によって，背景色を変えることができます．
第1引数：なし # markdown の記述例は以下のとおりです．
{{&amp;lt; hint &amp;gt;}} ヒント． {{&amp;lt; /hint &amp;gt;}} 出力結果は以下のとおりです．
ヒント． 第1引数：info # markdown の記述例は以下のとおりです．
{{&amp;lt; hint info &amp;gt;}} ヒント． {{&amp;lt; /hint &amp;gt;}} 出力結果は以下のとおりです．
ヒント． 第1引数：warning # markdown の記述例は以下のとおりです．
{{&amp;lt; hint warning &amp;gt;}} ヒント． {{&amp;lt; /hint &amp;gt;}} 出力結果は以下のとおりです．</description></item><item><title>サイコロを無限回投げる場合の確率モデル</title><link>https://htakeuchi0.github.io/docs/math/stat/dice/dice_inf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/stat/dice/dice_inf/</guid><description>サイコロを無限回投げる場合の確率モデル # 概要 # 前ページまでで，サイコロを繰り返し投げる試行の確率モデルを定義しました．しかし，投げる回数 \(N\) を固定した場合でしか説明していません．
本ページでは，サイコロを無限回投げる場合の確率モデルについて説明します．有限の場合ほど明らかではないので，ひとつずつ確認しながら構成します．
確率の定義 # 既に述べたとおり， \(\Omega\) を集合， \(\mathfrak{F}\) を \(\Omega\) の完全加法族としたとき，以下を満たす関数 \(P:\mathfrak{F}\to\mathbb{R}\) を確率と呼ぶのでした．
\(A\in\mathfrak{F}\) ならば \(P(A)\ge0\), \(P(\Omega)=1\), \(A_1,A_2,\dots\in\mathfrak{F}\) が互いに素ならば，\(P(\sum_{i=1}^{\infty}A_i)=\sum_{i=1}^{\infty}P(A_i)\). また， \((\Omega,\mathfrak{F},P)\) を確率空間と呼ぶのでした．
サイコロを無限回投げる場合を表す確率空間の具体的構成 # 以降では，サイコロを無限回投げる場合を表す確率空間 \((\Omega_{\infty},\mathfrak{F}_{\infty},P_{\infty})\) を具体的に構成します．
\(\Omega_\infty\) の構成 # \(\Omega_1=\{\omega_1,\omega_2,\dots,\omega_6\}\) とし， \(\Omega_{\infty}\) を，
\[\Omega_{\infty}=\{(\omega^i)_{i\in\mathbb{N}}\mid\forall i\in\mathbb{N}\,(\omega^i\in\Omega_1)\}\] つまり， \(\Omega_{\infty}=\Omega^{\mathbb{N}}\) とします1, 2．
\(\mathfrak{F}_{\infty},P_{\infty}\) の構成 # \(\mathfrak{F}_{\infty},P_{\infty}\) を定めるには準備が必要です． まず， \(1\le k\in\mathbb{N}\) について， \[N^{(k)}=\{(n_1,n_2,\dots,n_k)\in\mathbb{N}^k\mid 1\le n_1&amp;lt;\dots&amp;lt;n_k\}\] とし， \(N^{(0)}=\{\emptyset\}\) とします．
次に， \(1\le k\in\mathbb{N}\) に対し， \(\Omega\in2^{\Omega_1^k},n\in N^{(k)}\) に対して， \[F_{k,\Omega,n}=\{\omega\in\Omega_{\infty}\mid(\omega^{n_1},\omega^{n_2},\dots,\omega^{n_k})\in\Omega\}\] とし， \(F_{0,\{\emptyset\},n}=\Omega_{\infty},F_{0,\emptyset,n}=\emptyset\) とします．</description></item></channel></rss>