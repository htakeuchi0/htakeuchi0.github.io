<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ホームページ on htakeuchi0 のノート</title><link>https://htakeuchi0.github.io/</link><description>Recent content in ホームページ on htakeuchi0 のノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Thu, 11 Aug 2022 12:18:39 +0900</lastBuildDate><atom:link href="https://htakeuchi0.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>プロジェクトマネジメント知識体系 (PMBOK) ガイドに関するノート</title><link>https://htakeuchi0.github.io/docs/others/pmbok/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/others/pmbok/</guid><description>プロジェクトマネジメント知識体系 (PMBOK) ガイドに関するノート # 概要 # 本ページでは，プロジェクトマネジメント協会 (PMI) が発行するプロジェクトマネジメント知識体系 (PMBOK) ガイドの第6版日本語版 [1]，第7版日本語版 [2] の違いについてまとめます．
はじめに # プロジェクトマネジメントに関する知識を体系化したものとして，プロジェクトマネジメント協会 (PMI) が発行する プロジェクトマネジメント知識体系 (PMBOK) ガイドが広く知られています．
近年 (2022年11月)， PMI 日本支部より，PMBOK ガイド第7版の日本語版 [2] が刊行されました．
本ページでは，PMBOK ガイド第6版日本語版 [1]，第7版日本語版 [2] の違いを中心に，それら概要をまとめます．
第6版・第7版の違い # 本節では，第6版日本語版・第7版日本語版（以下，単に第6版，第7版と呼ぶ）の違いについて述べます． この違いを明確にする目的で，第6版，第7版の概要をまとめます．
まず，第6版の概要は以下のとおりです．
PMBOK ガイドはプロジェクトマネジメント標準に基づきまたこれを含む． PMBOK ガイドおよびプロジェクトマネジメント標準は規律的実務慣行でなく，模範的実務慣行に基づく． PMBOK ガイドが述べるのは知識体系であり方法論ではない． プロジェクトマネジメント標準は特定のプロセスまたは実務慣行の実施を要求するものではない． プロジェクト・ライフサイクルは，プロジェクトマネジメント・プロセス（以下，プロセス）を実施することでマネジメントされる． プロセスはインプットがあり，ツールや技法の適用を経てアウトプットを生成するものである (ITTO)． プロセスは5個のプロジェクトマネジメント・プロセス群（以下，プロセス群）に分類される． プロセスは10個の知識エリアにも分類される． 知識エリアとは，知識に対する要求事項によって定義されたものである． プロセスは次の事項を通して，一貫した予測可能な実務慣行を可能とする1． 文書化できる． プロセスに対するパフォーマンスを評価できる． 効率を最大化し，脅威を最小化するようにプロセスを改善できる． PMBOK ガイドの後にプロジェクトマネジメント標準を置く構成とした． 次に，第7版の（特に第6版との差分に着目した）概要は以下のとおりです．
成果物でなく意図した成果をより重視するため，原理・原則ベースの標準に移行した． プロセスベースの標準は本質的に規範的である． 過去のプロセスベース指向では価値実現の全貌を示すための方法として維持できない． 過去の版のプロセスベース・アプローチとの整合を無効にする内容は存在しない． プロジェクトマネジメント標準の価値実現の全体観に始まり，その後 PMBOK ガイドの内容表現へと続く構成とした． 10個の知識エリアは8個のパフォーマンス領域へ変更した． PMBOK ガイドにテーラリング2 専用の章を設けた． PMBOK ガイドに「モデル，方法，作成物」という章を設けたが，これは ITTO とのリンクが維持され拡張されるものである． 以上より，価値実現・成果に重きがおかれるようになり，より実務的慣行に基づくようにするため，第6版までのプロセスベースでなく，原理・原則ベースの標準に移行した，という趣旨が読み取れます．</description></item><item><title>指数関数の定積分</title><link>https://htakeuchi0.github.io/docs/math/exp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/exp/</guid><description>指数関数の定積分 # 概要 # 本ページでは，指数関数に関するいくつかの定積分の求め方と結果を説明します． 指数関数 \(\exp:\mathbb{R}\to\mathbb{R}\) とは， \[\exp(x)=\sum_{k=0}^n\frac{x^k}{k!}\] で定められる関数であり， \(\exp&amp;#39;(x)=\exp(x)\) が成り立つことが知られています．
本ページでは，以下の定積分の求め方と結果をまとめます．
\(\int_{\alpha}^{\beta}\exp(x)dx\) \(\int_{\alpha}^{\beta}\exp(ax&amp;#43;b)dx\) \(\int_{\alpha}^{\beta}\exp(ax^2&amp;#43;bx&amp;#43;c)dx\quad(a&amp;lt;0)\) ただし，以下の関数を既知とします．この関数は，相補誤差関数と呼ばれ，たとえば C++ の標準ライブラリで std::erfc として定義されています． \[\mathrm{erfc}(x)=\frac{2}{\sqrt{\pi}}\int_x^{\infty}e^{-t^2}dt\] 定積分1 # まず， \(\int_{\alpha}^{\beta}\exp(x)dx\) を計算します． これは， \(\exp&amp;#39;(x)=\exp(x)\) なので， \[\int_{\alpha}^{\beta}\exp(x)dx=\exp(\beta)-\exp(\alpha)\] です．
定積分2 # 次に， \(\int_{\alpha}^{\beta}\exp(ax&amp;#43;b)dx\) を計算します． これには，[1, 定理5.6] を利用します．
Theorem 1. (変数変換公式 [1, 定理5.6]) 関数 \(f,\phi\) が次の 1&amp;ndash;4 を満たすと仮定する．
\(f(x)\) は区間 \(I=[a,b]\) で連続， \(\phi(t)\) は区間 \(J=[\alpha,\beta]\) で微分可能， \(\phi&amp;#39;(t)\) は \(J\) で有界可積分（例えば連続）， \(\phi(J)\subset I\) , \(\phi(\alpha)=a\) , \(\phi(\beta)=b\) . このとき，次の等式が成り立つ． \[\int_a^bf(x)dx=\int_{\alpha}^{\beta}f(\phi(t))\phi&amp;#39;(t)dt.</description></item><item><title>空のサイトの生成</title><link>https://htakeuchi0.github.io/docs/hugo/base/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/hugo/base/</guid><description>空のサイトの生成 # 概要 # 本ページでは，Hugo による Web サイト作成の最初のステップについて説明します． 具体的には，ローカルに空のサイトが生成できるところまで説明します．
インストール # Hugo の Quick Start に従い，Hugo をインストールします．
作者の作成環境は Linux OS 64bit (Ubuntu 18.04.6 LTS) なので，Hugo のインストールページ を参考に，以下のコマンドを実行します．
$ snap install hugo --channel=extended デスクトップ環境なので，認証のためのダイアログが表示され，パスワードを入力して認証をクリックしました．
以下のコマンドでインストールが成功したかを確認できます．
$ hugo version hugo v0.101.0-9f74196ce611cdf6d355bfb99fd8eba5c68ef7f8+extended linux/amd64 BuildDate=2022-06-28T10:02:18Z VendorInfo=snap サイトの生成 # 以下のコマンドを実行します．
$ hugo new site htakeuchi0-notebook テーマの追加 # 本サイトでは，Book テーマを利用しています． 当該テーマの README にしたがって，以下のコマンドを実行します．
$ cd htakeuchi0-notebook $ git init $ git branch -M main $ git submodule add https://github.</description></item><item><title>関数ポインタとその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/fp/fp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/fp/</guid><description>関数ポインタとその周辺 # 概要 # ポインタ (pointer) とは，メモリアドレスを格納するためのオブジェクトのことです． C++ では，変数のメモリアドレスはもちろん，関数のエントリーポイントとなるメモリアドレスを格納することができます．
本ページでは，Newton 法という数値解法の実装を例とし，関数ポインタについて説明します．
Newton 法とその素朴な実装 # Newton 法とは，導関数が既知である実数値関数の零点を求める数値解法のひとつです． 近似解を中心に関数を一次近似（接線で近似）し，その一次関数の零点（その接線と \(x\) 軸の交点）に近似解を更新する，という操作を繰り返すことで数値的解を求めます．
具体的にいえば，初期値を \(x_0\) としたとき，近似解の更新式は，
\[x_{k&amp;#43;1}=x_k-\frac{f(x_k)}{f&amp;#39;(x_k)},\quad k=0,1,\dots\] となります．
関数 f, 導関数 df に対して，初期点 x0 に最も近い零点を求めるための関数 Newton の素朴な実装として，以下が考えられます． ここでは，収束判定条件を \(|f(x_k)|&amp;lt;\epsilon\) \((\epsilon&amp;gt;0)\) とし， 最大反復回数 loop_max を超えたら収束しなかった旨のエラーを返すようにしています．
#include &amp;lt;cmath&amp;gt; #include &amp;lt;exception&amp;gt; #include &amp;lt;iostream&amp;gt; double f(double x) { return x*x - 2; } double df(double x) { return 2*x; } double Newton(double x0, double eps=1.0e-10, std::size_t loop_max=1024) { double x = x0; for (std::size_t i = 0; i &amp;lt; loop_max; i++) { x -= f(x) / df(x); if (std::abs(f(x)) &amp;lt; eps) { return x; } } throw std::runtime_error(&amp;#34;Not convergence.</description></item><item><title>ページの追加とサイトの設定</title><link>https://htakeuchi0.github.io/docs/hugo/set_config/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/hugo/set_config/</guid><description>ページの追加とサイトの設定 # 概要 # 本ページでは，Hugo による Web サイト作成における，ページの追加とサイトの設定に関する部分を説明します．
ホームページの作成 # まずは，サイト全体のホームページ（トップページ）を作成します． 以下のコマンドを実行すると，ホームページが作成されます．
$ hugo new _index.md content/_index.md が生成されているので，それを以下のように書き換えます． タイトルと適当な小見出しを作成しており，メニューからリンクを張るため，免責事項とプライバシーポリシーは，別名でアンカーを作成しています．
--- title: &amp;#34;ホームページ&amp;#34; date: 2022-08-11T12:18:39+09:00 draft: true --- # htakeuchi0 のノート ## 概要 ## 免責事項 {#disclaimer} ## プライバシーポリシー {#privacy_policy} ## 作者について ## お問い合わせ 次に，設定ファイル confing.toml を以下のようにします．
baseURL = &amp;#39;https://htakeuchi0.github.io/&amp;#39; languageCode = &amp;#39;ja-jp&amp;#39; title = &amp;#39;htakeuchi0 のノート&amp;#39; theme = &amp;#39;hugo-book&amp;#39; enableGitInfo = true [params] BookTheme = &amp;#39;auto&amp;#39; BookRepo = &amp;#39;https://github.com/htakeuchi0/htakeuchi0.github.io-sources&amp;#39; BookSearch = false [menu] [[menu.</description></item><item><title>メンバ関数ポインタとその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/fp/mfp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/mfp/</guid><description>メンバ関数ポインタとその周辺 # 概要 # ポインタ (pointer) とは，メモリアドレスを格納するためのオブジェクトのことで，関数のエントリーポイントとなるメモリアドレスを格納できます（関数ポインタ）．
前節は，関数ポインタを利用して，関数を引数にとる関数が実現できることを確認しました． 本ページでは，関数がクラスのメンバ関数の場合にどうなるかについて説明します．
クラス定義とオブジェクト指向に基づく通常の対応 # 前節の関数を多項式関数に限定します． そのため，多項式関数を表すクラス Polynomial を以下のように用意したとします．
#include &amp;lt;initializer_list&amp;gt; #include &amp;lt;vector&amp;gt; /** * @brief 多項式関数を表すクラス． * * 例えば f(x) = x^2 - 2 の表現と f(1.0) の計算は以下のようにできる． * * Polynomial f = { -2, 0, 1 }; // x^2 - 2 = -2 + 0x + 1x^2 * std::cout &amp;lt;&amp;lt; f.Eval(1.0) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; // -1.0 (=f(1.0)) */ class Polynomial { public: Polynomial(std::initializer_list&amp;lt;double&amp;gt; init) : coeffs_(init.</description></item><item><title>指数関数の定積分：正規分布の累積分布関数の計算への応用</title><link>https://htakeuchi0.github.io/docs/math/exp_normal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/exp_normal/</guid><description>指数関数の定積分：正規分布の累積分布関数の計算への応用 # 概要 # 指数関数の定積分 のページでは，指数関数に関するいくつかの定積分の表示について説明しました．本ページでは，その応用として，正規分布の累積分布関数の計算への応用について説明します．
例えば，C++17 では，標準ライブラリに std::erfc 関数（相補誤差関数）がありますが，正規分布の累積分布関数を直接計算する関数は提供されていません．
しかし，相補誤差関数と正規分布の累積分布関数はスケールが異なるだけなので，std::erfc 関数があれば，正規分布の累積分布関数は計算できます．
そこで，本ページでは，指数関数の定積分 の結果を用いて，相補誤差関数と正規分布の累積分布関数の具体的な関係式を導出します．
正規分布 # 正規分布 とは，連続型確率変数のしたがう確率分布のひとつで，様々な場面で用いられます．
平均 \(\mu\) , 分散 \(\sigma^2\) の正規分布の 確率密度関数 は， \[f_X(x)=\frac{1}{\sqrt{2\pi\sigma^2}}\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)\] と表されます． ここで， \[F_X(x)=\int_{-\infty}^xf_X(x)dx\] とおくと， \(F_X(x)\) は，正規分布に従う確率変数 \(X\) が \(x\) 以下である確率を表します． 一般に，確率密度関数 \(f_X\) を用いて上記の \(F_X\) のように定義される関数を 累積分布関数 と呼びます．
正規分布の累積分布関数と誤差関数 # いま， \[-\frac{(x-\mu)^2}{2\sigma^2}=-\frac{1}{2\sigma^2}x^2&amp;#43;\frac{\mu}{\sigma^2}x-\frac{\mu^2}{2\sigma^2}\] なので， \[\begin{aligned} &amp;amp;a=-\frac{1}{2\sigma^2},\\ &amp;amp;b=\frac{\mu}{\sigma^2},\\ &amp;amp;c=-\frac{\mu^2}{2\sigma^2} \end{aligned}\] として，指数関数の定積分の定積分3を適用すると， \[\begin{aligned} &amp;amp;\frac{\sqrt{\pi}}{2\sqrt{-a}}=\frac{\sqrt{\pi}}{2\sqrt{1/(2\sigma^2)}} =\frac{\sqrt{\pi}\sqrt{\sigma^2}}{\sqrt{2}},\\ &amp;amp;\frac{b^2-4ac}{4a}=\frac{b^2}{4a}-c=\frac{\mu^2/\sigma^4}{-2/\sigma^2}-\left(-\frac{\mu^2}{2\sigma^2}\right)=0\\ &amp;amp;\frac{b}{2a} =\frac{\mu/\sigma^2}{-1/\sigma^2} =-\mu \end{aligned}\] より， \[\begin{aligned} &amp;amp;\int_{\alpha}^{\beta}\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)dx\\ &amp;amp;=\frac{\sqrt{\pi}\sqrt{\sigma^2}}{\sqrt{2}}\\ &amp;amp;\quad\times\left(\mathrm{erfc}\left(\frac{1}{\sqrt{2\sigma^2}}(\alpha-\mu)\right)-\mathrm{erfc}\left(\frac{1}{\sqrt{2\sigma^2}}(\beta-\mu)\right)\right) \end{aligned}\] となります．特に， \(\beta=x\) , \(\alpha\to-\infty\) のとき， \[\begin{aligned} &amp;amp;\int_{-\infty}^x\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)dx\\ &amp;amp;=\frac{\sqrt{\pi}\sqrt{\sigma^2}}{\sqrt{2}}\left(2-\mathrm{erfc}\left(\frac{1}{\sqrt{2\sigma^2}}(x-\mu)\right)\right) \end{aligned}\] です．</description></item><item><title>std::function とその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/fp/stdfunc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/stdfunc/</guid><description>std::function とその周辺 # 概要 # 前節までは，関数ポインタやメンバ関数ポインタについて説明しました． 本ページでは，標準ライブラリ std::function を利用する方法について説明します．
実用上は std::function を使う方法で十分と思います．
std::function について # functional ヘッダを include すると，std::function が利用できます． std::function の定義は以下のとおりです [1]． テンプレートクラスですが，テンプレートの特殊化によって，関数型のみが受け付けられるようになっています．
template &amp;lt;class&amp;gt; class function; /* undefined */ template &amp;lt;class R, class... Args&amp;gt; class function&amp;lt;R(Args...)&amp;gt;; まず，Args... は可変テンプレート引数の型を表します． よって，R(Args...) は 戻り値の型が R で，引数の型が Args... である関数の型です． したがって，Newton 関数を以下のように定義しておけば，f, df は関数を渡せます．
#include &amp;lt;cmath&amp;gt; #include &amp;lt;functional&amp;gt; using func_t = std::function&amp;lt;double(double)&amp;gt;; double Newton(func_t f, func_t df, double x0, double eps=1.0e-10, std::size_t loop_max=1024) { double x = x0; for (std::size_t i = 0; i &amp;lt; loop_max; i++) { x -= f(x) / df(x); if (std::abs(f(x)) &amp;lt; eps) { return x; } } throw std::runtime_error(&amp;#34;Not convergence.</description></item><item><title>公開用ファイルの生成</title><link>https://htakeuchi0.github.io/docs/hugo/genpages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/hugo/genpages/</guid><description>公開用ファイルの生成 # 概要 # 本ページでは，Hugo で作成した markdown ファイルを公開用の html ファイルにビルドして，公開する方法について説明します．
htmlファイルの生成 # 以下のコマンドを実行すると，public ディレクトリ以下に公開用ファイル一式が生成されます．
$ hugo --minify -D ページの公開 # 本サイトは，Github Pages [1] を利用してページを公開しています． 作者は，作成用ファイルと公開ファイルを 別リポジトリで管理しています．
htakeuchi0.github.io リポジトリ：公開用 htakeuchi0.github.io-sources リポジトリ：作成用 Hugo では [2] のように，同一リポジトリで別ブランチで管理する方法が説明されています．
本サイトの管理方法の場合，htakeuchi0.github.io-sources リポジトリ側で public 以下に生成されたファイルすべてを，htakeuchi0.github.io リポジトリに配置します．
あとは，[1] のとおりに設定すれば，数分でブラウザからアクセスできるようになります．
Google Search Console の設定 # Hugo では（少なくとも Book テーマでは），サイトマップ用の sitemap.xml とRSS用の index.xml が生成されているので，それぞれを Google Search Console [3] に登録するだけです．
まとめ # 本ページでは，公開ファイルを生成して，公開する方法について説明しました．
参考文献 # [1] Github, &amp;ldquo;About GitHub Pages - GitHub Docs&amp;rdquo;, https://docs.</description></item><item><title>関数への参照</title><link>https://htakeuchi0.github.io/docs/cpp/fp/fref/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/fref/</guid><description>関数への参照 # 概要 # 前節までで，関数ポインタとその周辺事項について説明しました． 本ページでは，関数への参照型について説明します．
関数ポインタ # 戻り値の型が T, 第 \(k\) 番目の引数の型が Sk である関数への関数ポインタ型は，
using fp_t = T (*)(S1, S2,..., Sn); または，
using f_t = T(S1, S2,..., Sn); using fp_t = f_t*; として定義できるのでした．
ここで，
using fref_t = T (&amp;amp;)(S1, S2,..., Sn); または，
using f_t = T(S1, S2,..., Sn); using fref_t = f_t&amp;amp;; とすると，関数への参照型 をつくることができます．
つまり，下記のコードをコンパイルして実行することができます．
#include &amp;lt;cmath&amp;gt; #include &amp;lt;exception&amp;gt; #include &amp;lt;iostream&amp;gt; using fref_t = double (&amp;amp;)(double); double Newton(fref_t f, fref_t df, double x0, double eps=1.</description></item></channel></rss>