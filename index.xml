<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>htakeuchi0 のノート</title><link>https://htakeuchi0.github.io/</link><description>Recent content on htakeuchi0 のノート</description><generator>Hugo</generator><language>ja-jp</language><lastBuildDate>Mon, 10 Feb 2025 20:57:18 +0900</lastBuildDate><atom:link href="https://htakeuchi0.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>2023 - 実装改良編</title><link>https://htakeuchi0.github.io/docs/math/year2023/year2023_2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/year2023/year2023_2/</guid><description>&lt;h1 id="2023---実装改良編">
 2023 - 実装改良編
 &lt;a class="anchor" href="#2023---%e5%ae%9f%e8%a3%85%e6%94%b9%e8%89%af%e7%b7%a8">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://htakeuchi0.github.io/docs/math/year2023/">前ページ&lt;/a>では，&lt;/p>

&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \[2023=(2+0+2+3)(2^2+0^2+2^2+3^2)^2\]
&lt;/span>

&lt;p>であることに着目して，以下の問題を解いたのでした．&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;b>Problem 1&lt;/b>.
整数 \(x=\sum_{j=0}^{n-1}a_j10^j\) \((0\le a_j\le 9,j=0,1,\dots,n-1)\) に対して，
\[ \prod_{k=1}^K\sum_{j=0}^{n-1}a_j^{i_k}=x \]
を満たす整数 \(K\ge1\), \(1\le i_1\le\cdots\le i_K\) が存在するかを判定せよ．存在する場合はこの方程式を満たす \((i_1,i_2,\dots,i_K)\) をひとつ求めよ．&lt;/p>
&lt;/blockquote>
&lt;p>本ページでは，そこで解説した解法を改良する方法を説明します．
その後，改良前後で実行時間を比較します．ただし，結果はほとんど変わりませんでした．&lt;/p>
&lt;h2 id="実装改良">
 実装改良
 &lt;a class="anchor" href="#%e5%ae%9f%e8%a3%85%e6%94%b9%e8%89%af">#&lt;/a>
&lt;/h2>
&lt;p>前ページで解説した解法は以下のとおりでした&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>．&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;b>Algorithm 2&lt;/b>.
\(\mathtt{Solve}(a, x, i)\) の擬似コードを以下で定める．ただし，\((a_1,\dots,a_n)\in\mathbb{N}^n,(b_1,\dots,b_m)\in\mathbb{N}^m\) に対して，\(\mathtt{append}(a,b)=(a_1,\dots,a_n,b_1,\dots,b_m)\in\mathbb{N}^{n+m}\) とする．&lt;/p>
&lt;ul>
&lt;li>Input: \(a\in\mathbb{N}^n,x\in\mathbb{N},i\in\mathbb{N}\)&lt;/li>
&lt;li>Output: \(\prod_{k=1}^K\sum_{j=0}^{n-1}a_j^{i_k}=x,i\le i_1\le\dots\le i_K\) を満たす \((i_1,i_2,\dots,i_K)\)&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>if \(\max(a)\le1\) then&lt;/li>
&lt;li>  if \(i&amp;gt;1\) then return \(\emptyset\)&lt;/li>
&lt;li>  if \(\sum_{j=0}^{n-1}a_j=x\) then return \((1)\)&lt;/li>
&lt;li>  else return \(\emptyset\)&lt;/li>
&lt;li>end if&lt;/li>
&lt;li>for \(i&amp;rsquo;=i,i+1,\dots\) do&lt;/li>
&lt;li>  \(y\leftarrow\sum_{j=0}^{n-1}a_j^{i&amp;rsquo;}\)&lt;/li>
&lt;li>  if \(y&amp;gt;x\) then return \(\emptyset\)&lt;/li>
&lt;li>  if \(y=x\) then return \((i&amp;rsquo;)\)&lt;/li>
&lt;li>  if \(y\mid x\) then&lt;/li>
&lt;li>    \(L\leftarrow\mathtt{Solve}(a,x/y,i&amp;rsquo;)\)&lt;/li>
&lt;li>    if \(L=\emptyset\) then return \(\emptyset\)&lt;/li>
&lt;li>    else return \(\mathtt{append}((i&amp;rsquo;),L)\)&lt;/li>
&lt;li>  end if&lt;/li>
&lt;li>end for&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>このアルゴリズムは，11行目によって再帰処理になっていますが， &lt;strong>再帰させずに，単に &lt;span>
 \(x\)
&lt;/span>
 を &lt;span>
 \(x/y\)
&lt;/span>
 に置き換えて処理を継続させることができます．&lt;/strong> この場合，再帰処理用に用意していた第3引数の &lt;span>
 \(i\)
&lt;/span>
 が不要になります．&lt;/p></description></item><item><title>Makefile プロジェクト</title><link>https://htakeuchi0.github.io/docs/cpp/env/make/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/env/make/</guid><description>&lt;h1 id="makefile-プロジェクト">
 Makefile プロジェクト
 &lt;a class="anchor" href="#makefile-%e3%83%97%e3%83%ad%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>本ページでは，Makefile を使ったプロジェクトのディレクトリ構成の例を説明します．&lt;/p>
&lt;p>&lt;code>cpp_env_sample&lt;/code> ディレクトリ以下にソースコードなどを配置することとします．&lt;/p>
&lt;h2 id="github-リポジトリ">
 Github リポジトリ
 &lt;a class="anchor" href="#github-%e3%83%aa%e3%83%9d%e3%82%b8%e3%83%88%e3%83%aa">#&lt;/a>
&lt;/h2>
&lt;p>本ページで説明するディレクトリ構成のプロジェクトは，以下の Github リポジトリ &lt;a href="#cite:1">[1]&lt;/a> として公開しています．&lt;/p>
&lt;p>&lt;a href="https://github.com/htakeuchi0/cpp_env_sample">https://github.com/htakeuchi0/cpp_env_sample&lt;/a>&lt;/p>
&lt;p>本ページは CC BY 4.0 のもとで提供していますが，このリポジトリはMITライセンスで公開しています．&lt;/p>
&lt;h2 id="動作環境">
 動作環境
 &lt;a class="anchor" href="#%e5%8b%95%e4%bd%9c%e7%92%b0%e5%a2%83">#&lt;/a>
&lt;/h2>
&lt;p>本ページで説明するものは，以下の環境で動作するものです．&lt;/p>
&lt;ul>
&lt;li>
&lt;p>OS: Linux (Ubuntu 18.04.5 LTS)&lt;/p>
&lt;ul>
&lt;li>コンパイラ: g++ (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>OS: Linux (Ubuntu 20.04.1 LTS)&lt;/p>
&lt;ul>
&lt;li>コンパイラ: g++ (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>単体試験，カバレッジ計測，ドキュメント生成に，それぞれ以下を利用するものとします．&lt;/p>
&lt;ul>
&lt;li>Google Test &lt;a href="#cite:2">[2]&lt;/a>&lt;/li>
&lt;li>LCOV &lt;a href="#cite:3">[3]&lt;/a>&lt;/li>
&lt;li>Doxygen &lt;a href="#cite:4">[4]&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="ディレクトリ構成">
 ディレクトリ構成
 &lt;a class="anchor" href="#%e3%83%87%e3%82%a3%e3%83%ac%e3%82%af%e3%83%88%e3%83%aa%e6%a7%8b%e6%88%90">#&lt;/a>
&lt;/h2>
&lt;p>ディレクトリ構成の例は以下の通りです．&lt;/p>
&lt;pre tabindex="0">&lt;code>|- cpp_env_sample/
 |- Doxyfile - doxygen設定ファイル
 |- LICENSE - ライセンスファイル
 |- Makefile - makeファイル
 |- README.md - READMEファイル
 |- include/ - ヘッダファイル
 | |- cpp_env_sample/
 | |- example.h
 |
 |- main/ - メインファイル
 | |- main.cc
 |
 |- scripts/ - 環境構築用スクリプト
 | |- install_doxygen.sh
 | |- install_gtest.sh
 | |- install_lcov.sh
 |
 |- src/ - ソースファイル
 | |- example.cc
 |
 |- test/ - テストファイル
 |- gtest_example.cc
&lt;/code>&lt;/pre>&lt;h2 id="ソースコード関連のディレクトリ">
 ソースコード関連のディレクトリ
 &lt;a class="anchor" href="#%e3%82%bd%e3%83%bc%e3%82%b9%e3%82%b3%e3%83%bc%e3%83%89%e9%96%a2%e9%80%a3%e3%81%ae%e3%83%87%e3%82%a3%e3%83%ac%e3%82%af%e3%83%88%e3%83%aa">#&lt;/a>
&lt;/h2>
&lt;p>ソースコード関連のディレクトリを抜き出すと以下のとおりです．&lt;/p></description></item><item><title>Picard の定理</title><link>https://htakeuchi0.github.io/docs/math/complex/picard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/complex/picard/</guid><description>&lt;h1 id="picard-の定理">
 Picard の定理
 &lt;a class="anchor" href="#picard-%e3%81%ae%e5%ae%9a%e7%90%86">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>複素数上で定義された関数を扱う分野は，複素解析や &lt;strong>函数論&lt;/strong> と呼ばれます．&lt;/p>
&lt;p>複素解析・函数論の教科書は多く執筆されていますが，吉田洋一の『函数論』&lt;a href="#cite:1">[1]&lt;/a> が古典的名著として知られています．&lt;/p>
&lt;p>本ページでは，その中から，&lt;strong>Picard の定理&lt;/strong> について概説します．&lt;/p>
&lt;p>Picard の定理は &lt;strong>真性特異点&lt;/strong> の性質を述べた定理です．
この定理から，真性特異点のまわりでは函数が複雑なふるまいをすることがわかります．&lt;/p>
&lt;p>真性特異点とは 
&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \(\exp(1/z)\)
&lt;/span>
 の &lt;span>
 \(z=0\)
&lt;/span>
 のような点をいいます．
&lt;span>
 \(1/z\)
&lt;/span>
 の &lt;span>
 \(z=0\)
&lt;/span>
 と似ていますが，これは真性特異点ではありません．
&lt;span>
 \(1/z\)
&lt;/span>
 の &lt;span>
 \(z=0\)
&lt;/span>
 のまわりより，&lt;span>
 \(\exp(1/z)\)
&lt;/span>
 の &lt;span>
 \(z=0\)
&lt;/span>
 のまわりの方が，函数は様々な値をとります．&lt;/p>
&lt;h2 id="picard-の定理-1">
 Picard の定理
 &lt;a class="anchor" href="#picard-%e3%81%ae%e5%ae%9a%e7%90%86-1">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="#cite:1">[1]&lt;/a> の &lt;span>
 \(\S\)
&lt;/span>
59 では，以下の主張がなされています．&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;b>Theorem 1&lt;/b> (Picard の定理 &lt;a href="#cite:1">[1]&lt;/a>).
\(f(z)\) は \(0&amp;lt;|z-c|&amp;lt;R\) で有理型で，\(c\) は \(f(z)\) の真性特異点であるとする．しかるときは&lt;/p>
&lt;p>\[ 0&amp;lt;|z-c|&amp;lt;R\quad\text{では}\quad f(z)\neq\omega\]&lt;/p>
&lt;p>であるような \(\omega\) は，もしあるにしても，その数は2個を超えることはない．&lt;/p>
&lt;/blockquote>
&lt;p>&lt;span>
 \(f\)
&lt;/span>
 が有理型という仮定がありますが，これが正則である場合の記述を目にすることの方が多いかもしれません．&lt;/p></description></item><item><title>サイコロを繰り返し投げる試行の確率モデル</title><link>https://htakeuchi0.github.io/docs/math/stat/dice/dice_basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/stat/dice/dice_basic/</guid><description>&lt;h1 id="サイコロを繰り返し投げる試行の確率モデル">
 サイコロを繰り返し投げる試行の確率モデル
 &lt;a class="anchor" href="#%e3%82%b5%e3%82%a4%e3%82%b3%e3%83%ad%e3%82%92%e7%b9%b0%e3%82%8a%e8%bf%94%e3%81%97%e6%8a%95%e3%81%92%e3%82%8b%e8%a9%a6%e8%a1%8c%e3%81%ae%e7%a2%ba%e7%8e%87%e3%83%a2%e3%83%87%e3%83%ab">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>本ページでは，サイコロを繰り返し投げる試行の確率モデルを定義します．&lt;/p>
&lt;h2 id="確率の定義">
 確率の定義
 &lt;a class="anchor" href="#%e7%a2%ba%e7%8e%87%e3%81%ae%e5%ae%9a%e7%be%a9">#&lt;/a>
&lt;/h2>
&lt;p>確率の定義は以下の通りです．&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;b>Definition 1&lt;/b>.&lt;/p>
&lt;ol>
&lt;li>\(X\) を集合とする．\(\mathfrak{F}\subset2^X\) が \(X\) の完全加法族であるとは，次の1&amp;ndash;3を満たすことである．ただし，\(A^c=X-A={x\in X\mid x\notin a}\), \(2^X={A\mid A\subset X}\) とする．
&lt;ol>
&lt;li>\(\emptyset\in\mathfrak{F}\),&lt;/li>
&lt;li>\(A\in\mathfrak{F}\) ならば \(A^c\in\mathfrak{F}\),&lt;/li>
&lt;li>任意の \(i\in\mathbb{N}\) について \(A_i\in\mathfrak{F}\) ならば \(\bigcup_{i=1}^{\infty}A_i\in\mathfrak{F}\).&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>\(\Omega\) を集合とし，\(\mathfrak{F}\) を \(\Omega\) の完全加法族とする．\((\Omega,\mathfrak{F})\) を&lt;strong>標本空間&lt;/strong>, \(\mathfrak{F}\) の点を&lt;strong>事象&lt;/strong>，\(\Omega\) の点を&lt;strong>標本点&lt;/strong>という．&lt;/li>
&lt;li>\(\Omega\) を集合とし，\(\mathfrak{F}\) を \(\Omega\) の完全加法族とする．関数 \(P:\mathfrak{F}\to\mathbb{R}\) が次の1&amp;ndash;3を満たすとき，関数 \(P\) を&lt;strong>確率&lt;/strong>という．ただし，集合 \(A_1,A_2,\dots\) が互いに素とは，どの \(i,j\ (i\neq j)\) についても \(A_i\cap A_j=\emptyset\) であることをいい，\(A_1,A_2,\dots\) が互いに素であるとき，\(\bigcup_{i=1}^{\infty}A_i\) を \(\sum_{i=1}^{\infty}A_i\) と表す．
&lt;ol>
&lt;li>\(A\in\mathfrak{F}\) ならば \(P(A)\ge0\),&lt;/li>
&lt;li>\(P(\Omega)=1\),&lt;/li>
&lt;li>\(A_1,A_2,\dots\in\mathfrak{F}\) が互いに素ならば，\(P(\sum_{i=1}^{\infty}A_i)=\sum_{i=1}^{\infty}P(A_i)\).&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>\(\Omega\) を集合とし，\(\mathfrak{F}\) を \(\Omega\) の完全加法族とする．関数 \(P:\mathfrak{F}\to\mathbb{R}\) を確率とする．このとき，\((\Omega,\mathfrak{F},P)\) を&lt;strong>確率空間&lt;/strong>という．&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h2 id="偏りのないサイコロを1回だけ投げる試行の確率モデル">
 偏りのないサイコロを1回だけ投げる試行の確率モデル
 &lt;a class="anchor" href="#%e5%81%8f%e3%82%8a%e3%81%ae%e3%81%aa%e3%81%84%e3%82%b5%e3%82%a4%e3%82%b3%e3%83%ad%e3%82%921%e5%9b%9e%e3%81%a0%e3%81%91%e6%8a%95%e3%81%92%e3%82%8b%e8%a9%a6%e8%a1%8c%e3%81%ae%e7%a2%ba%e7%8e%87%e3%83%a2%e3%83%87%e3%83%ab">#&lt;/a>
&lt;/h2>
&lt;p>まずは，偏りのないサイコロを1回だけ投げる試行の確率モデルを考えます．&lt;/p></description></item><item><title>ジョーンズ マクロ経済学Ⅰ</title><link>https://htakeuchi0.github.io/docs/others/macroeconomics/jones-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/others/macroeconomics/jones-1/</guid><description>&lt;h1 id="ジョーンズ-マクロ経済学">
 ジョーンズ マクロ経済学Ⅰ
 &lt;a class="anchor" href="#%e3%82%b8%e3%83%a7%e3%83%bc%e3%83%b3%e3%82%ba-%e3%83%9e%e3%82%af%e3%83%ad%e7%b5%8c%e6%b8%88%e5%ad%a6">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>手取りを増やすことを公約に掲げた政党の台頭が示すように，昨今，日本経済再生への期待が高まっています．
本ページは，国の経済全体に関する経済学についてのノートです．&lt;/p>
&lt;p>経済を構成する個々の主体に着目するミクロ経済学に対し，それらを合わせて一国の経済全体に着目する経済学の領域は &lt;strong>マクロ経済学&lt;/strong> と呼ばれます．
本ページでは，作成者が『ジョーンズ マクロ経済学Ⅰ 長期成長編』&lt;a href="#cite:1">[1]&lt;/a> を初読した際のメモをまとめます．
本ページの作成者は，&lt;a href="#cite:1">[1]&lt;/a> を読むまで，経済学に関する知識を一切有していませんでした．&lt;/p>
&lt;p>本教科書 &lt;a href="#cite:1">[1]&lt;/a> は，簡単な数式を使って説明がなされており，数式に抵抗がない初心者にとってはわかりやすく感じました．
本ページでは，数式で表現された箇所を中心に，初読時のメモを整理して記載します．&lt;/p>
&lt;p>本ページは解説文ではなく，あくまでメモの整理として数式で表されたモデルを中心にまとめますが，本教科書 &lt;a href="#cite:1">[1]&lt;/a> は数式ばかりがでてくるものではありません．
また，本文中にもあるように，マクロ経済学は数式のみから議論・検討を行う学問でないこともお断りしておきます．&lt;/p>
&lt;h2 id="第1章-マクロ経済学への招待">
 第1章 マクロ経済学への招待
 &lt;a class="anchor" href="#%e7%ac%ac1%e7%ab%a0-%e3%83%9e%e3%82%af%e3%83%ad%e7%b5%8c%e6%b8%88%e5%ad%a6%e3%81%b8%e3%81%ae%e6%8b%9b%e5%be%85">#&lt;/a>
&lt;/h2>
&lt;p>マクロ経済学の方法は以下のとおりです．&lt;/p>
&lt;ol>
&lt;li>事実を記述する．&lt;/li>
&lt;li>&lt;strong>モデル&lt;/strong> を開発する．&lt;/li>
&lt;li>モデルから導き出される予見と元の事実とを比較する．&lt;/li>
&lt;li>モデルを使って他のケースの予見を行う．&lt;/li>
&lt;/ol>
&lt;p>本ページでは，特に項番2にあるように，どのようなモデルが知られているかに着目してまとめます．&lt;/p>
&lt;p>モデルの入力は &lt;strong>パラメータ&lt;/strong> と &lt;strong>外生変数&lt;/strong> で，出力は &lt;strong>内生変数&lt;/strong> であると整理されます．&lt;/p>
&lt;pre tabindex="0">&lt;code>パラメータ -----&amp;gt; モデル ----&amp;gt; 内生変数
外生変数
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>パラメータ：モデルの外から与える定数&lt;/li>
&lt;li>外生変数：モデルの外から与える変数（時間的変化を許す）&lt;/li>
&lt;li>内生変数：未知数に相当する変数&lt;/li>
&lt;/ul>
&lt;p>以下，外から与えられるものを 
&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \(\bar{\cdot}\)
&lt;/span>
 と上線を付けた記号で表します．&lt;/p>
&lt;h2 id="第2章-マクロ経済学の計測">
 第2章 マクロ経済学の計測
 &lt;a class="anchor" href="#%e7%ac%ac2%e7%ab%a0-%e3%83%9e%e3%82%af%e3%83%ad%e7%b5%8c%e6%b8%88%e5%ad%a6%e3%81%ae%e8%a8%88%e6%b8%ac">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>GDP&lt;/strong> とは国内生産とのことです．
&lt;strong>生産＝支出＝所得&lt;/strong> の関係が基本的原則で，それぞれの観点からGDPを計算しても同じ値となります．&lt;/p>
&lt;p>GDP の支出アプローチでは，GDP は以下の式で表されます．&lt;/p>
&lt;span>
 \[
Y=C+I+G+\mathit{NX}
\]
&lt;/span>

&lt;p>記号の意味は以下のとおりです．&lt;/p></description></item><item><title>プロジェクトマネジメント知識体系 (PMBOK) ガイドに関するノート</title><link>https://htakeuchi0.github.io/docs/others/pmbok/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/others/pmbok/</guid><description>&lt;h1 id="プロジェクトマネジメント知識体系-pmbok-ガイドに関するノート">
 プロジェクトマネジメント知識体系 (PMBOK) ガイドに関するノート
 &lt;a class="anchor" href="#%e3%83%97%e3%83%ad%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e3%83%9e%e3%83%8d%e3%82%b8%e3%83%a1%e3%83%b3%e3%83%88%e7%9f%a5%e8%ad%98%e4%bd%93%e7%b3%bb-pmbok-%e3%82%ac%e3%82%a4%e3%83%89%e3%81%ab%e9%96%a2%e3%81%99%e3%82%8b%e3%83%8e%e3%83%bc%e3%83%88">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>本ページでは，プロジェクトマネジメント協会 (PMI) が発行するプロジェクトマネジメント知識体系 (PMBOK) ガイドの第6版日本語版 &lt;a href="#cite:1">[1]&lt;/a>，第7版日本語版 &lt;a href="#cite:2">[2]&lt;/a> の違いについてまとめます．&lt;/p>
&lt;h2 id="はじめに">
 はじめに
 &lt;a class="anchor" href="#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab">#&lt;/a>
&lt;/h2>
&lt;p>プロジェクトマネジメントに関する知識を体系化したものとして，プロジェクトマネジメント協会 (PMI) が発行する プロジェクトマネジメント知識体系 (PMBOK) ガイドが広く知られています．&lt;/p>
&lt;p>近年 (2022年11月)， PMI 日本支部より，PMBOK ガイド第7版の日本語版 &lt;a href="#cite:2">[2]&lt;/a> が刊行されました．&lt;/p>
&lt;p>本ページでは，PMBOK ガイド第6版日本語版 &lt;a href="#cite:1">[1]&lt;/a>，第7版日本語版 &lt;a href="#cite:2">[2]&lt;/a> の違いを中心に，それら概要をまとめます．&lt;/p>
&lt;h2 id="第6版第7版の違い">
 第6版・第7版の違い
 &lt;a class="anchor" href="#%e7%ac%ac6%e7%89%88%e7%ac%ac7%e7%89%88%e3%81%ae%e9%81%95%e3%81%84">#&lt;/a>
&lt;/h2>
&lt;p>本節では，第6版日本語版・第7版日本語版（以下，単に第6版，第7版と呼ぶ）の違いについて述べます．
この違いを明確にする目的で，第6版，第7版の概要をまとめます．&lt;/p>
&lt;p>まず，第6版の概要は以下のとおりです．&lt;/p>
&lt;ul>
&lt;li>PMBOK ガイドはプロジェクトマネジメント標準に基づきまたこれを含む．&lt;/li>
&lt;li>PMBOK ガイドおよびプロジェクトマネジメント標準は規律的実務慣行でなく，模範的実務慣行に基づく．&lt;/li>
&lt;li>PMBOK ガイドが述べるのは知識体系であり方法論ではない．&lt;/li>
&lt;li>プロジェクトマネジメント標準は特定のプロセスまたは実務慣行の実施を要求するものではない．&lt;/li>
&lt;li>プロジェクト・ライフサイクルは，プロジェクトマネジメント・プロセス（以下，プロセス）を実施することでマネジメントされる．&lt;/li>
&lt;li>プロセスはインプットがあり，ツールや技法の適用を経てアウトプットを生成するものである (ITTO)．&lt;/li>
&lt;li>プロセスは5個のプロジェクトマネジメント・プロセス群（以下，プロセス群）に分類される．&lt;/li>
&lt;li>プロセスは10個の知識エリアにも分類される．
&lt;ul>
&lt;li>知識エリアとは，知識に対する要求事項によって定義されたものである．&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>プロセスは次の事項を通して，一貫した予測可能な実務慣行を可能とする&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>．
&lt;ul>
&lt;li>文書化できる．&lt;/li>
&lt;li>プロセスに対するパフォーマンスを評価できる．&lt;/li>
&lt;li>効率を最大化し，脅威を最小化するようにプロセスを改善できる．&lt;/li>
&lt;li>PMBOK ガイドの後にプロジェクトマネジメント標準を置く構成とした．&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>次に，第7版の（特に第6版との差分に着目した）概要は以下のとおりです．&lt;/p>
&lt;ul>
&lt;li>成果物でなく意図した成果をより重視するため，原理・原則ベースの標準に移行した．
&lt;ul>
&lt;li>プロセスベースの標準は本質的に規範的である．&lt;/li>
&lt;li>過去のプロセスベース指向では価値実現の全貌を示すための方法として維持できない．&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>過去の版のプロセスベース・アプローチとの整合を無効にする内容は存在しない．&lt;/li>
&lt;li>プロジェクトマネジメント標準の価値実現の全体観に始まり，その後 PMBOK ガイドの内容表現へと続く構成とした．&lt;/li>
&lt;li>10個の知識エリアは8個のパフォーマンス領域へ変更した．&lt;/li>
&lt;li>PMBOK ガイドにテーラリング&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> 専用の章を設けた．&lt;/li>
&lt;li>PMBOK ガイドに「モデル，方法，作成物」という章を設けたが，これは ITTO とのリンクが維持され拡張されるものである．&lt;/li>
&lt;/ul>
&lt;p>以上より，価値実現・成果に重きがおかれるようになり，より実務的慣行に基づくようにするため，第6版までのプロセスベースでなく，原理・原則ベースの標準に移行した，という趣旨が読み取れます．&lt;/p></description></item><item><title>ラプラス分布と切断ラプラス分布</title><link>https://htakeuchi0.github.io/docs/math/stat/lap/trunclap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/stat/lap/trunclap/</guid><description>&lt;h1 id="ラプラス分布と切断ラプラス分布">
 ラプラス分布と切断ラプラス分布
 &lt;a class="anchor" href="#%e3%83%a9%e3%83%97%e3%83%a9%e3%82%b9%e5%88%86%e5%b8%83%e3%81%a8%e5%88%87%e6%96%ad%e3%83%a9%e3%83%97%e3%83%a9%e3%82%b9%e5%88%86%e5%b8%83">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>本ページでは，ラプラス分布と切断ラプラス分布の定義を述べ，切断ラプラス分布の確率密度関数，累積分布関数を具体的に求めます．&lt;/p>
&lt;h2 id="ラプラス分布と切断ラプラス分布の定義">
 ラプラス分布と切断ラプラス分布の定義
 &lt;a class="anchor" href="#%e3%83%a9%e3%83%97%e3%83%a9%e3%82%b9%e5%88%86%e5%b8%83%e3%81%a8%e5%88%87%e6%96%ad%e3%83%a9%e3%83%97%e3%83%a9%e3%82%b9%e5%88%86%e5%b8%83%e3%81%ae%e5%ae%9a%e7%be%a9">#&lt;/a>
&lt;/h2>
&lt;p>まずは，ラプラス分布を定義します．
切断ラプラス分布に従う確率変数に 
&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \(X\)
&lt;/span>
 の文字を使うため，ラプラス分布に従う確率変数には &lt;span>
 \(Y\)
&lt;/span>
 を使います．&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;b>Definition 1&lt;/b>.
\(\mu,b\in\mathbb{R}\), \(b&amp;gt;0\) とする．
連続的確率変数 \(Y:(\Omega,\mathfrak{F})\to(\mathbb{R},\mathfrak{B}[\mathbb{R}])\) の確率密度関数 \(f_Y\) が
\[
f_Y(y;\mu,b)=\frac{1}{2b}\exp\left(-\frac{|y-\mu|}{b}\right)
\]
と表されるとき，\(Y\) を &lt;strong>ラプラス分布&lt;/strong> に従う確率変数であるという．&lt;/p>
&lt;/blockquote>
&lt;p>ラプラス分布はどのような実数でもとり得る分布ですが，これを区間 &lt;span>
 \([A,B]\,(A\le B)\)
&lt;/span>
 に制限した分布を &lt;strong>切断ラプラス分布&lt;/strong> といいます．&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;b>Definition 2&lt;/b>.
\(\mu,b\in\mathbb{R}\), \(b&amp;gt;0\), \(A,B\in\mathbb{R}\), \(A\le B\) とする．連続的確率変数 \(X:(\Omega,\mathfrak{F})\to(\mathbb{R},\mathfrak{B}[\mathbb{R}])\) の確率密度関数 \(f_X\) が
\[
f_X(x;\mu,b,A,B)=\begin{cases}
\dfrac{1}{2bC}\exp\left(-\dfrac{|x-\mu|}{b}\right),&amp;amp;A\le x\le B,\\
0,&amp;amp;\text{otherwise}
\end{cases}
\]
と表されるとき，\(X\) を &lt;strong>切断ラプラス分布&lt;/strong> に従う確率変数であるという．&lt;/p>
&lt;/blockquote>
&lt;h2 id="切断ラプラス分布の確率密度関数">
 切断ラプラス分布の確率密度関数
 &lt;a class="anchor" href="#%e5%88%87%e6%96%ad%e3%83%a9%e3%83%97%e3%83%a9%e3%82%b9%e5%88%86%e5%b8%83%e3%81%ae%e7%a2%ba%e7%8e%87%e5%af%86%e5%ba%a6%e9%96%a2%e6%95%b0">#&lt;/a>
&lt;/h2>
&lt;p>以下，Definition 2 の &lt;span>
 \(C\)
&lt;/span>
 を具体的に求めてみます．
&lt;span>
 \(C\)
&lt;/span>
 は &lt;span>
 \(\mu,b,A,B\)
&lt;/span>
 から決まるので， &lt;span>
 \(C_{\mu,b}(A,B)\)
&lt;/span>
 と表します．&lt;/p></description></item><item><title>レール</title><link>https://htakeuchi0.github.io/docs/math/plarail/rail/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/plarail/rail/</guid><description>&lt;h1 id="レール">
 レール
 &lt;a class="anchor" href="#%e3%83%ac%e3%83%bc%e3%83%ab">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>タカラトミーのプラレールという鉄道玩具が広く知られています &lt;a href="#takaratomy:1">[1]&lt;/a>．本ページでは，プラレールにおける，レールの数学的表現を考えます．&lt;/p>
&lt;h2 id="レールの数学的表現">
 レールの数学的表現
 &lt;a class="anchor" href="#%e3%83%ac%e3%83%bc%e3%83%ab%e3%81%ae%e6%95%b0%e5%ad%a6%e7%9a%84%e8%a1%a8%e7%8f%be">#&lt;/a>
&lt;/h2>
&lt;p>レールは直線や曲線のものが基本的ですが，ほかに，並走するもの，分岐するもの，高さが変わるものなどがあります．また，レール同士の接続部は，凹凸の形状になっています．さらに，一部を除き，裏返しても使えるようになっています．&lt;/p>
&lt;p>以上をふまえ，レールの形式的定義を以下のようにまとめます．&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;b>Definition 1&lt;/b>.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>\(\Phi\) を，以下を満たす写像 \(\phi\) 全体の集合とする．&lt;/p>
&lt;ul>
&lt;li>\(\phi:\{\theta\in\mathbb{R}\mid 0&amp;lt;\theta&amp;lt;1\}\to\mathbb{R}^3\) である．&lt;/li>
&lt;li>\(\phi\) は単射である．&lt;/li>
&lt;li>\(\lim_{\theta\to0}\phi(\theta)=0\) であり，\(\lim_{\theta\to1}\phi(\theta)\) が存在する．&lt;/li>
&lt;li>\(\phi\) は連続で，\(\lim_{\theta\to0}\phi'(\theta)/\|\phi'(\theta)\|_2\), \(\lim_{\theta\to1}\phi'(\theta)/\|\phi'(\theta)\|_2\) が存在する．&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>\(\mathcal{T}=\{+,-,\bot\}\) とする．&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\(1\) 以上の整数 \(n, m\) に対し，\(\Psi_{n,m}\) を，以下を満たす写像 \(\psi\) 全体の集合とする．&lt;/p>
&lt;ul>
&lt;li>\(\psi:\{1,2,\dots,n\}\times\{0,1\}\to\{1,2,\dots,m\}\) である．&lt;/li>
&lt;li>\(\psi\) は全射である．&lt;/li>
&lt;li>\(i=1,2,\dots,n\) について \(\psi(i,0)\not=\psi(i,1)\) である．&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>以下の集合 \(\mathcal{R}\) の元 \(r\) を &lt;strong>レール&lt;/strong> という．&lt;/p>
&lt;/li>
&lt;/ol>
&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \[
\begin{aligned}
&amp;\mathcal{R}=\bigg\{(\phi_1,\dots,\phi_n,t_1,\dots,t_m,\psi,u_1,\dots,u_{n-1})\\
&amp;\quad\in\left(\bigcup_{m=1,2,\dots}(\Phi\times\mathcal{T}^m\times\Psi_{1,m})\right)\cup\left(\bigcup_{\begin{subarray}{c}n=2,3,\dots,\\m=1,2,\dots\end{subarray}}(\Phi^n\times\mathcal{T}^m\times\Psi_{n,m}\times(\mathbb{R}^3)^{n-1})\right)\,\bigg|\\
&amp;\qquad\qquad\qquad\forall i,j\,(t_{\psi(i,j)}\not=\bot\implies\forall i',j'\,(i\not=i'\implies \psi(i,j)\not=\psi(i',j')))\bigg\}
\end{aligned}
\]
&lt;/span>
&lt;/blockquote>
&lt;p>&lt;span>
 \(\phi_i\,(1\le i\le n)\)
&lt;/span>
 は単純な曲線（自己交差のない曲線）です．つまり上の定義では，レールは，1個以上の単純な曲線で構成されるものであることを要請しています．次に，&lt;span>
 \(t_i\,(1\le i\le m)\)
&lt;/span>
 は接続部の形状を表します．単純曲線同士の内部結合点は &lt;span>
 \(\bot\)
&lt;/span>
 で表します．&lt;span>
 \(\psi\)
&lt;/span>
 は曲線 &lt;span>
 \(\phi_i\,(1\le i\le n)\)
&lt;/span>
 の端点と，接続形状 &lt;span>
 \(t_i\,(1\le i\le m)\)
&lt;/span>
 との対応を表します．&lt;span>
 \(u_i\,(1\le i\le n-1)\)
&lt;/span>
 は &lt;span>
 \(\phi_i\,(2\le i\le n)\)
&lt;/span>
 の &lt;span>
 \(\theta=0\)
&lt;/span>
 側の点の，&lt;span>
 \(\lim_{\theta\to0}\phi_1(\theta)\)
&lt;/span>
 からの変位を表します．&lt;/p></description></item><item><title>指数関数の定積分</title><link>https://htakeuchi0.github.io/docs/math/exp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/exp/</guid><description>&lt;h1 id="指数関数の定積分">
 指数関数の定積分
 &lt;a class="anchor" href="#%e6%8c%87%e6%95%b0%e9%96%a2%e6%95%b0%e3%81%ae%e5%ae%9a%e7%a9%8d%e5%88%86">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>本ページでは，指数関数に関するいくつかの定積分の求め方と結果を説明します．
指数関数 &lt;span>
 \(\exp:\mathbb{R}\to\mathbb{R}\)
&lt;/span>
とは，
&lt;span>
 \[
\exp(x)=\sum_{k=0}^n\frac{x^k}{k!}
\]
&lt;/span>

で定められる関数であり，&lt;span>
 \(\exp'(x)=\exp(x)\)
&lt;/span>
が成り立つことが知られています．&lt;/p>
&lt;p>本ページでは，以下の定積分の求め方と結果をまとめます．&lt;/p>
&lt;ol>
&lt;li>&lt;span>
 \(\int_{\alpha}^{\beta}\exp(x)dx\)
&lt;/span>
&lt;/li>
&lt;li>&lt;span>
 \(\int_{\alpha}^{\beta}\exp(ax+b)dx\quad(a\not=0)\)
&lt;/span>
&lt;/li>
&lt;li>&lt;span>
 \(\int_{\alpha}^{\beta}\exp(ax^2+bx+c)dx\quad(a&lt;0)\)
&lt;/span>
&lt;/li>
&lt;/ol>
&lt;p>ただし，以下の関数を既知とします．この関数は，&lt;strong>相補誤差関数&lt;/strong>と呼ばれ，たとえば C++ の標準ライブラリで &lt;code>std::erfc&lt;/code> として定義されています．&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;b>Definition 1&lt;/b>.
相補誤差関数 \(\mathrm{erfc}:\mathbb{R}\to\mathbb{R}\) を以下のように定める．&lt;/p>
&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \[
\mathrm{erfc}(x)=\frac{2}{\sqrt{\pi}}\int_x^{\infty}\exp(-t^2)dt.
\]
&lt;/span>
&lt;/blockquote>
&lt;h2 id="定積分1">
 定積分1
 &lt;a class="anchor" href="#%e5%ae%9a%e7%a9%8d%e5%88%861">#&lt;/a>
&lt;/h2>
&lt;p>まず，&lt;span>
 \(\int_{\alpha}^{\beta}\exp(x)dx\)
&lt;/span>
 を計算します．
これは，&lt;span>
 \(\exp'(x)=\exp(x)\)
&lt;/span>
なので，
&lt;span>
 \[
\int_{\alpha}^{\beta}\exp(x)dx=\exp(\beta)-\exp(\alpha)
\]
&lt;/span>

です．&lt;/p>
&lt;h2 id="定積分2">
 定積分2
 &lt;a class="anchor" href="#%e5%ae%9a%e7%a9%8d%e5%88%862">#&lt;/a>
&lt;/h2>
&lt;p>次に，&lt;span>
 \(\int_{\alpha}^{\beta}\exp(ax+b)dx\ (a\not=0)\)
&lt;/span>
 を計算します． &lt;br>
これには，&lt;a href="#cite:1">[1, 定理5.6]&lt;/a> を利用します．&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;b>Theorem 2&lt;/b>.
関数 \(f,\phi\) が次の 1&amp;ndash;4 を満たすと仮定する．&lt;/p></description></item><item><title>空のサイトの生成</title><link>https://htakeuchi0.github.io/docs/hugo/base/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/hugo/base/</guid><description>&lt;h1 id="空のサイトの生成">
 空のサイトの生成
 &lt;a class="anchor" href="#%e7%a9%ba%e3%81%ae%e3%82%b5%e3%82%a4%e3%83%88%e3%81%ae%e7%94%9f%e6%88%90">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>本ページでは，Hugo による Web サイト作成の最初のステップについて説明します． &lt;br>
具体的には，ローカルに空のサイトが生成できるところまで説明します．&lt;/p>
&lt;h2 id="インストール">
 インストール
 &lt;a class="anchor" href="#%e3%82%a4%e3%83%b3%e3%82%b9%e3%83%88%e3%83%bc%e3%83%ab">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://gohugo.io/getting-started/quick-start/">Hugo の Quick Start&lt;/a> に従い，Hugo をインストールします．&lt;/p>
&lt;p>作者の作成環境は Linux OS 64bit (Ubuntu 18.04.6 LTS) なので，&lt;a href="https://gohugo.io/getting-started/installing">Hugo のインストールページ&lt;/a> を参考に，以下のコマンドを実行します．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ snap install hugo --channel&lt;span style="color:#f92672">=&lt;/span>extended
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>デスクトップ環境なので，認証のためのダイアログが表示され，パスワードを入力して認証をクリックしました．&lt;/p>
&lt;p>以下のコマンドでインストールが成功したかを確認できます．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ hugo version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo v0.101.0-9f74196ce611cdf6d355bfb99fd8eba5c68ef7f8+extended linux/amd64 BuildDate&lt;span style="color:#f92672">=&lt;/span>2022-06-28T10:02:18Z VendorInfo&lt;span style="color:#f92672">=&lt;/span>snap
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="サイトの生成">
 サイトの生成
 &lt;a class="anchor" href="#%e3%82%b5%e3%82%a4%e3%83%88%e3%81%ae%e7%94%9f%e6%88%90">#&lt;/a>
&lt;/h2>
&lt;p>以下のコマンドを実行します．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ hugo new site htakeuchi0-notebook
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="テーマの追加">
 テーマの追加
 &lt;a class="anchor" href="#%e3%83%86%e3%83%bc%e3%83%9e%e3%81%ae%e8%bf%bd%e5%8a%a0">#&lt;/a>
&lt;/h2>
&lt;p>本サイトでは，&lt;a href="https://themes.gohugo.io/themes/hugo-book/">Book&lt;/a> テーマを利用しています．
当該テーマの README にしたがって，以下のコマンドを実行します．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cd htakeuchi0-notebook
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git init
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git branch -M main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ git submodule add https://github.com/alex-shpak/hugo-book themes/hugo-book
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>つまり，テーマはサブモジュールとして取り込むこととして，ついでにブランチ名を &lt;code>main&lt;/code> に変更しておきます．&lt;/p></description></item><item><title>行列を表現するデータ構造と行列積の計算時間</title><link>https://htakeuchi0.github.io/docs/cpp/mmul/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/mmul/basic/</guid><description>&lt;h1 id="行列を表現するデータ構造と行列積の計算時間">
 行列を表現するデータ構造と行列積の計算時間
 &lt;a class="anchor" href="#%e8%a1%8c%e5%88%97%e3%82%92%e8%a1%a8%e7%8f%be%e3%81%99%e3%82%8b%e3%83%87%e3%83%bc%e3%82%bf%e6%a7%8b%e9%80%a0%e3%81%a8%e8%a1%8c%e5%88%97%e7%a9%8d%e3%81%ae%e8%a8%88%e7%ae%97%e6%99%82%e9%96%93">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>
&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \(A=(a_{ij})\)
&lt;/span>
, &lt;span>
 \(B=(b_{ij})\)
&lt;/span>
 を &lt;span>
 \(n\)
&lt;/span>
 次正方行列とします．
行列 &lt;span>
 \(A\)
&lt;/span>
, &lt;span>
 \(B\)
&lt;/span>
 の積 &lt;span>
 \(AB\)
&lt;/span>
 は
&lt;span>
 \[
(AB)_{ij}=\sum_{k=0}^{n-1}a_{ik}b_{kj},\quad 0\le i &lt; n,\quad 0\le j &lt; n
\]
&lt;/span>

と定義されます&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>．ただし，行列 &lt;span>
 \(M\)
&lt;/span>
 に対して，&lt;span>
 \((M)_{ij}\)
&lt;/span>
 で &lt;span>
 \(M\)
&lt;/span>
 の第 &lt;span>
 \((i,j)\)
&lt;/span>
 成分を表します．&lt;/p>
&lt;p>本ページでは，この行列積を，C++を用いていくつかの方針で実装し，実装方針による実行時間を比較します．&lt;/p>
&lt;p>実験用に使ったプログラムは以下に配置しています．&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/htakeuchi0/mmul-gcc-sample">https://github.com/htakeuchi0/mmul-gcc-sample&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>以下，&lt;span>
 \(n=256\)
&lt;/span>
 とし，&lt;span>
 \(A\)
&lt;/span>
, &lt;span>
 \(B\)
&lt;/span>
 の要素は倍精度浮動小数点数とします．&lt;/p>
&lt;h2 id="行列を表現するデータ構造と手順">
 行列を表現するデータ構造と手順
 &lt;a class="anchor" href="#%e8%a1%8c%e5%88%97%e3%82%92%e8%a1%a8%e7%8f%be%e3%81%99%e3%82%8b%e3%83%87%e3%83%bc%e3%82%bf%e6%a7%8b%e9%80%a0%e3%81%a8%e6%89%8b%e9%a0%86">#&lt;/a>
&lt;/h2>
&lt;p>はじめに，最も素朴な方法として，&lt;span>
 \(A\)
&lt;/span>
, &lt;span>
 \(B\)
&lt;/span>
 を2次元配列で表現することを考えます．
&lt;span>
 \(n\)
&lt;/span>
 を定数 &lt;code>kN&lt;/code> で表すとき，変数の宣言方法として，以下が考えられます．&lt;/p>
&lt;ul>
&lt;li>&lt;code>double a[kN][kN];&lt;/code>&lt;/li>
&lt;li>&lt;code>std::array&amp;lt;std::array&amp;lt;double, kN&amp;gt;, kN&amp;gt; a;&lt;/code>&lt;/li>
&lt;li>&lt;code>double **a = new double*[kN]; ... &lt;/code>&lt;/li>
&lt;li>&lt;code>std::vector&amp;lt;std::vector&amp;lt;double&amp;gt;&amp;gt; a;&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>これらはいずれも，&lt;code>a[i][j]&lt;/code> が &lt;span>
 \(a_{ij}\)
&lt;/span>
 を表すため，直感的です．
これらにそれぞれ，&lt;/p></description></item><item><title>配列へのポインタとその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/arrp/arrp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/arrp/arrp/</guid><description>&lt;h1 id="配列へのポインタとその周辺">
 配列へのポインタとその周辺
 &lt;a class="anchor" href="#%e9%85%8d%e5%88%97%e3%81%b8%e3%81%ae%e3%83%9d%e3%82%a4%e3%83%b3%e3%82%bf%e3%81%a8%e3%81%9d%e3%81%ae%e5%91%a8%e8%be%ba">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>配列とは，同じ型の複数の変数をまとめて扱うためのデータ構造です．&lt;/p>
&lt;p>ポインタ (pointer) とは，メモリアドレスを格納するためのオブジェクトのことです．
C++ では，変数のメモリアドレスはもちろん，関数のエントリーポイントとなるメモリアドレスを格納することができます．&lt;/p>
&lt;p>&lt;a href="https://htakeuchi0.github.io/docs/cpp/fp/">関数ポインタ&lt;/a> の節では，関数へのポインタについて説明しました．本ページでは，C++における配列とポインタの関係を説明した後，&lt;strong>配列型へのポインタ型&lt;/strong>について説明します．ここで，配列型へのポインタ型とは，そのポインタ型の変数に対して &lt;code>*&lt;/code> 演算子で値を得ると，要素ではなく，配列そのものが得られるようなポインタ型を指すものとします．&lt;/p>
&lt;h2 id="配列とポインタ">
 配列とポインタ
 &lt;a class="anchor" href="#%e9%85%8d%e5%88%97%e3%81%a8%e3%83%9d%e3%82%a4%e3%83%b3%e3%82%bf">#&lt;/a>
&lt;/h2>
&lt;p>配列とは，同じ型の複数の変数をまとめて扱うためのデータ構造です．例えば，&lt;code>int&lt;/code> 型の変数を10個まとめて扱うための配列は以下のように宣言できます．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> arr[&lt;span style="color:#ae81ff">10&lt;/span>];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使いかたは以下のとおりです．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> arr[&lt;span style="color:#ae81ff">10&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> arr[i] &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> arr[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> arr[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> arr[&lt;span style="color:#ae81ff">2&lt;/span>] &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// 4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配列変数は，変数からその要素数を取得する方法は，言語仕様としては提供されていません．ただし，C言語の時代から，配列変数の要素数を取得する方法として，以下の方法が広く知られています．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> arr[&lt;span style="color:#ae81ff">10&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(arr) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(arr[&lt;span style="color:#ae81ff">0&lt;/span>]);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは，&lt;code>sizeof&lt;/code> 演算子を利用して，配列全体のサイズを，配列の先頭要素のサイズで割れば，要素数が得られるという仕組みです．以下のように，関数形式マクロとして定義されることが多いです．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> arr[&lt;span style="color:#ae81ff">10&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> ARRAY_SIZE(arr) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// 10
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>さて，ある型の配列変数は，同じ型のポインタ型変数に代入できます．&lt;/p></description></item><item><title>関数ポインタとその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/fp/fp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/fp/</guid><description>&lt;h1 id="関数ポインタとその周辺">
 関数ポインタとその周辺
 &lt;a class="anchor" href="#%e9%96%a2%e6%95%b0%e3%83%9d%e3%82%a4%e3%83%b3%e3%82%bf%e3%81%a8%e3%81%9d%e3%81%ae%e5%91%a8%e8%be%ba">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>ポインタ (pointer) とは，メモリアドレスを格納するためのオブジェクトのことです．
C++ では，変数のメモリアドレスはもちろん，関数のエントリーポイントとなるメモリアドレスを格納することができます．&lt;/p>
&lt;p>本ページでは，Newton 法という数値解法の実装を例とし，関数ポインタについて説明します．&lt;/p>
&lt;h2 id="newton-法とその素朴な実装">
 Newton 法とその素朴な実装
 &lt;a class="anchor" href="#newton-%e6%b3%95%e3%81%a8%e3%81%9d%e3%81%ae%e7%b4%a0%e6%9c%b4%e3%81%aa%e5%ae%9f%e8%a3%85">#&lt;/a>
&lt;/h2>
&lt;p>Newton 法とは，導関数が既知である実数値関数の零点を求める数値解法のひとつです．
近似解を中心に関数を一次近似（接線で近似）し，その一次関数の零点（その接線と

&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \(x\)
&lt;/span>

軸の交点）に近似解を更新する，という操作を繰り返すことで数値的解を求めます．&lt;/p>
&lt;p>具体的にいえば，初期値を &lt;span>
 \(x_0\)
&lt;/span>
 としたとき，近似解の更新式は，&lt;/p>
&lt;span>
 \[
x_{k+1}=x_k-\frac{f(x_k)}{f'(x_k)},\quad k=0,1,\dots
\]
&lt;/span>

&lt;p>となります．&lt;/p>
&lt;p>関数 &lt;code>f&lt;/code>, 導関数 &lt;code>df&lt;/code> に対して，初期点 &lt;code>x0&lt;/code> に最も近い零点を求めるための関数 &lt;code>Newton&lt;/code> の素朴な実装として，以下が考えられます．
ここでは，収束判定条件を &lt;span>
 \(|f(x_k)|&lt;\epsilon\)
&lt;/span>
 &lt;span>
 \((\epsilon>0)\)
&lt;/span>
 とし，
最大反復回数 &lt;code>loop_max&lt;/code> を超えたら収束しなかった旨のエラーを返すようにしています．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;exception&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x&lt;span style="color:#f92672">*&lt;/span>x &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">df&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">*&lt;/span>x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">Newton&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> x0, &lt;span style="color:#66d9ef">double&lt;/span> eps&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1.0e-10&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>size_t loop_max&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1024&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> x0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>size_t i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> loop_max; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">-=&lt;/span> f(x) &lt;span style="color:#f92672">/&lt;/span> df(x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>abs(f(x)) &lt;span style="color:#f92672">&amp;lt;&lt;/span> eps) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>runtime_error(&lt;span style="color:#e6db74">&amp;#34;Convergence error: This method did not converge.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> x0 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1.0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> Newton(x0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl; &lt;span style="color:#75715e">// 1.41421
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>しかし，この実装方法では，対象となる関数 &lt;code>f&lt;/code> を変えるたびに，関数 &lt;code>f&lt;/code> の中身を書き換えるか，&lt;code>Newton&lt;/code> 内の &lt;code>f&lt;/code> を別の関数に置き換えるかが必要となり，不便です．
特に，複数の関数の零点を求めたい場合，求めるたびにソースコードの書き換えが必要になります．&lt;/p></description></item><item><title>autoconf プロジェクト (1)</title><link>https://htakeuchi0.github.io/docs/cpp/env/autoconf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/env/autoconf/</guid><description>&lt;h1 id="autoconf-プロジェクト-1">
 autoconf プロジェクト (1)
 &lt;a class="anchor" href="#autoconf-%e3%83%97%e3%83%ad%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88-1">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>前ページでは，Makefile プロジェクトの例について説明しました．本ページでは，autoconf を使った Makefile の自動生成について説明します．&lt;/p>
&lt;p>本ページでは，わかりやすさを優先し，やや不自然な箇所がありますが，できるだけ簡単な準備で autoconf による Makefile 生成と，make の実行を試みます．&lt;/p>
&lt;h2 id="準備">
 準備
 &lt;a class="anchor" href="#%e6%ba%96%e5%82%99">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://htakeuchi0.github.io/docs/cpp/env/make/">Makefile プロジェクト&lt;/a> のリポジトリからスタートします． &lt;br>
初期状態のディレクトリ構成は以下のとおりです．&lt;/p>
&lt;pre tabindex="0">&lt;code>|- cpp_env_sample/
 |- Doxyfile - doxygen設定ファイル
 |- LICENSE - ライセンスファイル
 |- Makefile - makeファイル
 |- README.md - READMEファイル
 |- include/ - ヘッダファイル
 | |- cpp_env_sample/
 | |- example.h
 |
 |- main/ - メインファイル
 | |- main.cc
 |
 |- scripts/ - 環境構築用スクリプト
 | |- install_doxygen.sh
 | |- install_gtest.sh
 | |- install_lcov.sh
 |
 |- src/ - ソースファイル
 | |- example.cc
 |
 |- test/ - テストファイル
 |- gtest_example.cc
&lt;/code>&lt;/pre>&lt;p>まず，これから自動生成する Makefile を削除しておきます．&lt;/p></description></item><item><title>サイコロをN回投げたときちょうど6回に1回の割合で1の目が出る確率</title><link>https://htakeuchi0.github.io/docs/math/stat/dice/dice_ratio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/stat/dice/dice_ratio/</guid><description>&lt;h1 id="サイコロをn回投げたときちょうど6回に1回の割合で1の目が出る確率">
 サイコロをN回投げたときちょうど6回に1回の割合で1の目が出る確率
 &lt;a class="anchor" href="#%e3%82%b5%e3%82%a4%e3%82%b3%e3%83%ad%e3%82%92n%e5%9b%9e%e6%8a%95%e3%81%92%e3%81%9f%e3%81%a8%e3%81%8d%e3%81%a1%e3%82%87%e3%81%86%e3%81%a96%e5%9b%9e%e3%81%ab1%e5%9b%9e%e3%81%ae%e5%89%b2%e5%90%88%e3%81%a71%e3%81%ae%e7%9b%ae%e3%81%8c%e5%87%ba%e3%82%8b%e7%a2%ba%e7%8e%87">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>前ページでは，サイコロを繰り返し投げる試行の確率モデルを定義しました．&lt;/p>
&lt;p>本ページからは，サイコロを繰り返し投げると，およそ6回に1回程度の割合で1の目が出ることを確認します．&lt;/p>
&lt;p>しかし，そもそもこれはどのように確認したらよいのでしょうか．&lt;/p>
&lt;p>本ページではひとまず，&lt;strong>ちょうど&lt;/strong> 6回に1回の割合で1の目が出る確率を計算してみます．&lt;/p>
&lt;p>まず，サイコロを
&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \(N\)
&lt;/span>
回投げたとき &lt;span>
 \(k\)
&lt;/span>
 回だけ1の目が出る確率を求めます．その後，サイコロを繰り返し投げたとき，&lt;strong>ちょうど&lt;/strong> 6回に1回の割合で1の目が出る確率を求めます．&lt;/p>
&lt;h2 id="サイコロをn回投げたときk回だけ1の目が出る確率">
 サイコロをN回投げたときk回だけ1の目が出る確率
 &lt;a class="anchor" href="#%e3%82%b5%e3%82%a4%e3%82%b3%e3%83%ad%e3%82%92n%e5%9b%9e%e6%8a%95%e3%81%92%e3%81%9f%e3%81%a8%e3%81%8dk%e5%9b%9e%e3%81%a0%e3%81%911%e3%81%ae%e7%9b%ae%e3%81%8c%e5%87%ba%e3%82%8b%e7%a2%ba%e7%8e%87">#&lt;/a>
&lt;/h2>
&lt;p>いま，確率空間 &lt;span>
 \((\Omega_N,\mathfrak{F}_N,P_N)\)
&lt;/span>
 を考えます．&lt;span>
 \(A_k=\{(\omega^j)\in\Omega_N\mid |\{j\mid \omega^j=\omega_1\}|=k\}\)
&lt;/span>
 とすると，&lt;span>
 \(A_k\)
&lt;/span>
 は &lt;span>
 \(N\)
&lt;/span>
 回サイコロをなげて &lt;span>
 \(k\)
&lt;/span>
 回だけ1の目が出た事象を表します．&lt;/p>
&lt;p>&lt;span>
 \((\omega^j)\in A_k\)
&lt;/span>
 とすると，&lt;span>
 \(\omega^1,\omega^2,\dots,\omega^N\)
&lt;/span>
 のうち &lt;span>
 \(k\)
&lt;/span>
個が &lt;span>
 \(\omega_1\)
&lt;/span>
ですが，これは&lt;span>
 \(N\)
&lt;/span>
個から&lt;span>
 \(k\)
&lt;/span>
個を選ぶ選び方を考えればよいので，&lt;span>
 \(\binom{N}{k}=N!/(k!(N-k)!)\)
&lt;/span>
個あります．&lt;/p>
&lt;p>このとき，ある &lt;span>
 \(\{i_1,i_2,\dots,i_k\}\subset\{1,2,\dots,N\}\)
&lt;/span>
 について，&lt;span>
 \(k\)
&lt;/span>
個の要素 &lt;span>
 \(\omega^{i_j}\,(j=1,2,\dots,k)\)
&lt;/span>
 は &lt;span>
 \(\omega_1\)
&lt;/span>
の1通りの値しかとれませんが，それ以外の &lt;span>
 \(N-k\)
&lt;/span>
 個の要素は &lt;span>
 \(\omega_2,\omega_3,\dots,\omega_6\)
&lt;/span>
 の5通りの値をとれます．&lt;/p>
&lt;p>したがって，&lt;span>
 \(|A_k|=\binom{N}{k}5^{N-k}\)
&lt;/span>
とわかります．さらに，&lt;span>
 \(|\Omega_N|=6^N\)
&lt;/span>
 なので，&lt;span>
 \(P_N(A_k)=\binom{N}{k}5^{N-k}/6^N\)
&lt;/span>
 となります．&lt;/p></description></item><item><title>ページの追加とサイトの設定</title><link>https://htakeuchi0.github.io/docs/hugo/set_config/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/hugo/set_config/</guid><description>&lt;h1 id="ページの追加とサイトの設定">
 ページの追加とサイトの設定
 &lt;a class="anchor" href="#%e3%83%9a%e3%83%bc%e3%82%b8%e3%81%ae%e8%bf%bd%e5%8a%a0%e3%81%a8%e3%82%b5%e3%82%a4%e3%83%88%e3%81%ae%e8%a8%ad%e5%ae%9a">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>本ページでは，Hugo による Web サイト作成における，ページの追加とサイトの設定に関する部分を説明します．&lt;/p>
&lt;h2 id="ホームページの作成">
 ホームページの作成
 &lt;a class="anchor" href="#%e3%83%9b%e3%83%bc%e3%83%a0%e3%83%9a%e3%83%bc%e3%82%b8%e3%81%ae%e4%bd%9c%e6%88%90">#&lt;/a>
&lt;/h2>
&lt;p>まずは，サイト全体のホームページ（トップページ）を作成します． &lt;br>
以下のコマンドを実行すると，ホームページが作成されます．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ hugo new _index.md
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>content/_index.md&lt;/code> が生成されているので，それを以下のように書き換えます． &lt;br>
タイトルと適当な小見出しを作成しており，メニューからリンクを張るため，免責事項とプライバシーポリシーは，別名でアンカーを作成しています．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-md" data-lang="md">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title: &amp;#34;ホームページ&amp;#34;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date: 2022-08-11T12:18:39+09:00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>draft: true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># htakeuchi0 のノート
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 概要
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 免責事項 {#disclaimer}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## プライバシーポリシー {#privacy_policy}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## 作者について
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## お問い合わせ
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>次に，設定ファイル &lt;code>confing.toml&lt;/code> を以下のようにします．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-toml" data-lang="toml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">baseURL&lt;/span> = &lt;span style="color:#e6db74">&amp;#39;https://htakeuchi0.github.io/&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">languageCode&lt;/span> = &lt;span style="color:#e6db74">&amp;#39;ja-jp&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">title&lt;/span> = &lt;span style="color:#e6db74">&amp;#39;htakeuchi0 のノート&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">theme&lt;/span> = &lt;span style="color:#e6db74">&amp;#39;hugo-book&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">enableGitInfo&lt;/span> = &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#a6e22e">params&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">BookTheme&lt;/span> = &lt;span style="color:#e6db74">&amp;#39;auto&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">BookRepo&lt;/span> = &lt;span style="color:#e6db74">&amp;#39;https://github.com/htakeuchi0/htakeuchi0.github.io-sources&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">BookSearch&lt;/span> = &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#a6e22e">menu&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [[&lt;span style="color:#a6e22e">menu&lt;/span>.&lt;span style="color:#a6e22e">after&lt;/span>]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">identifier&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;disclaimer&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;免責事項&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;免責事項&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">url&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;/#disclaimer&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">weight&lt;/span> = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [[&lt;span style="color:#a6e22e">menu&lt;/span>.&lt;span style="color:#a6e22e">after&lt;/span>]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">identifier&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;privacy_policy&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">name&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;プライバシーポリシー&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">title&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;プライバシーポリシー&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">url&lt;/span> = &lt;span style="color:#e6db74">&amp;#34;/#privacy_policy&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">weight&lt;/span> = &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>主に以下のような設定をしています． &lt;br>
なお，これら設定は Book テーマの場合になります．&lt;/p></description></item><item><title>メンバ関数ポインタとその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/fp/mfp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/mfp/</guid><description>&lt;h1 id="メンバ関数ポインタとその周辺">
 メンバ関数ポインタとその周辺
 &lt;a class="anchor" href="#%e3%83%a1%e3%83%b3%e3%83%90%e9%96%a2%e6%95%b0%e3%83%9d%e3%82%a4%e3%83%b3%e3%82%bf%e3%81%a8%e3%81%9d%e3%81%ae%e5%91%a8%e8%be%ba">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>ポインタ (pointer) とは，メモリアドレスを格納するためのオブジェクトのことで，関数のエントリーポイントとなるメモリアドレスを格納できます（関数ポインタ）．&lt;/p>
&lt;p>前ページでは，関数ポインタを利用して，関数を引数にとる関数が実現できることを確認しました．
本ページでは，関数がクラスのメンバ関数の場合にどうなるかについて説明します．&lt;/p>
&lt;h2 id="クラス定義とオブジェクト指向に基づく通常の対応">
 クラス定義とオブジェクト指向に基づく通常の対応
 &lt;a class="anchor" href="#%e3%82%af%e3%83%a9%e3%82%b9%e5%ae%9a%e7%be%a9%e3%81%a8%e3%82%aa%e3%83%96%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e6%8c%87%e5%90%91%e3%81%ab%e5%9f%ba%e3%81%a5%e3%81%8f%e9%80%9a%e5%b8%b8%e3%81%ae%e5%af%be%e5%bf%9c">#&lt;/a>
&lt;/h2>
&lt;p>前節の関数を多項式関数に限定します．
そのため，多項式関数を表すクラス &lt;code>Polynomial&lt;/code> を以下のように用意したとします．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;initializer_list&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @brief 多項式関数を表すクラス．
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * 例えば f(x) = x^2 - 2 の表現と f(1.0) の計算は以下のようにできる．
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Polynomial f = { -2, 0, 1 }; // x^2 - 2 = -2 + 0x + 1x^2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * std::cout &amp;lt;&amp;lt; f.Eval(1.0) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; // -1.0 (=f(1.0))
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Polynomial&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Polynomial(std&lt;span style="color:#f92672">::&lt;/span>initializer_list&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">double&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> init) &lt;span style="color:#f92672">:&lt;/span> coeffs_(init.begin(), init.end()) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">Eval&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> x) &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> iter &lt;span style="color:#f92672">=&lt;/span> coeffs_.crbegin();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> y &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (iter &lt;span style="color:#f92672">!=&lt;/span> coeffs_.crend()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y &lt;span style="color:#f92672">=&lt;/span> y&lt;span style="color:#f92672">*&lt;/span>x &lt;span style="color:#f92672">+&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>iter&lt;span style="color:#f92672">++&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> y;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">double&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> coeffs_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このクラスを使う場合，Newton メソッドの呼び出し部分はどうしたらよいでしょうか．
適当に書いてみると以下のようになります．&lt;/p></description></item><item><title>レイアウト</title><link>https://htakeuchi0.github.io/docs/math/plarail/layout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/plarail/layout/</guid><description>&lt;h1 id="レイアウト">
 レイアウト
 &lt;a class="anchor" href="#%e3%83%ac%e3%82%a4%e3%82%a2%e3%82%a6%e3%83%88">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>タカラトミーのプラレールという鉄道玩具が広く知られています &lt;a href="#takaratomy:1">[1]&lt;/a>．&lt;a href="https://htakeuchi0.github.io/docs/math/plarail/rail/">前ページ&lt;/a> では，プラレールのレールに関する形式的定義を与えました．本ページではレイアウト（線路配線）の数学的表現を考えます．&lt;/p>
&lt;h2 id="レイアウトの数学的表現">
 レイアウトの数学的表現
 &lt;a class="anchor" href="#%e3%83%ac%e3%82%a4%e3%82%a2%e3%82%a6%e3%83%88%e3%81%ae%e6%95%b0%e5%ad%a6%e7%9a%84%e8%a1%a8%e7%8f%be">#&lt;/a>
&lt;/h2>
&lt;p>一般に，プラレールの配線結果を &lt;strong>レイアウト&lt;/strong> と呼びますので，本ページでもそれにならいます．&lt;/p>
&lt;p>レイアウトを考えるとき，レール同士は斜めに接続できず，接続部が凹凸の組み合わせである必要があります．ここでは，特に配線結果が環状であることを要求しません．&lt;/p>
&lt;p>レールを頂点としたグラフを考えることで，レールごとの接続の仕方が表現できます．接続の仕方が決まると形状が決まりますが，これは各レールの端点や分岐点を頂点とする単純グラフで表現できます．以下，接続を表すグラフを &lt;strong>接続グラフ&lt;/strong>，形状を表すグラフを &lt;strong>形状グラフ&lt;/strong> とよぶことにします．
これらをふまえて，レイアウトの形式的定義を考えます．&lt;/p>
&lt;p>まず，そのレイアウトが実現できるかを確認する前段階である &lt;strong>擬レイアウト&lt;/strong> を定義します．&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;b>Definition 1&lt;/b>.&lt;/p>
&lt;ol>
&lt;li>\(\Gamma_m=(\mathbb{Z}^2\times(\mathbb{Z}^2)^*)^m \) とし，\(\Gamma^*\) の元を &lt;strong>接続情報&lt;/strong> と呼ぶ．ただし，集合 \(A\) に対して \(A^*=\bigcup_mA^m\) とする．&lt;/li>
&lt;li>\(\tilde{\mathcal{A}}\) を，以下を満たす \(R\) 全体の集合とし，\(\tilde{\mathcal{A}}\) の元 \(R\) を &lt;strong>擬レイアウト&lt;/strong> という．
&lt;ol>
&lt;li>\(R=(r,c)\in\bigcup_{n,m}(\mathcal{R}^n\times\Gamma_m)\) である．&lt;/li>
&lt;li>\(r=(r_i)_{1\le i\le n},c=(c_k)_{1\le k\le m}\) が，
\[
\begin{aligned}
&amp;amp;r_i=(\phi_1^i,\dots,\phi_{n_i}^i,t_1^i,\dots,t_{m_i}^i,\psi^i,u_1^i,\dots,u_{n_i-1}^i)\quad(1\le i\le n),\\
&amp;amp;c_k=((i_1^k,i_2^k),((j_{11}^k,j_{12}^k),\dots,(j_{l_k1}^k,j_{l_k2}^k)))\quad(1\le k\le m)
\end{aligned}
\]
と表せるとき，
&lt;ol>
&lt;li>任意の \(k=1,2,\dots,m\) について \(1\le i_1^k\le n\), \(1\le i_2^k\le n\) である．&lt;/li>
&lt;li>任意の \(k=1,2,\dots,m\) と \(l=1,2,\dots,l_k\) について，\(1\le j_{l1}^k\le m_{i_1^k}\), \(1\le j_{l2}^k\le m_{i_2^k}\) である．&lt;/li>
&lt;li>任意の \(k=1,2,\dots,m\) と \(l=1,2,\dots,l_k\) について，
&lt;ol>
&lt;li>\(t_{j_{l1}^k}^{i_1^k}\not=t_{j_{l2}^k}^{i_2^k},\quad t_{j_{l1}^k}^{i_1^k}\not=\bot,\quad t_{j_{l2}^k}^{i_2^k}\not=\bot\) である．&lt;/li>
&lt;li>\(\psi^{i_1^k}(k_1,l_1)=j_{l1}^k\), \(\psi^{i_2^k}(k_2,l_2)=j_{l1}^k\) となる \(k_1,k_2,l_1,l_2\) について，
\[ \lim_{x\to l_1}\frac{{\phi'}_{k_1}^{i_1^k}}{\|{\phi'}_{k_1}^{i_1^k}\|_2}=\lim_{x\to l_2}\frac{{\phi'}_{k_2}^{i_2^k}}{\|{\phi'}_{k_2}^{i_2^k}\|_2} \]
が成り立つ．&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>擬レイアウト \(R\in\tilde{\mathcal{A}}\) の &lt;strong>接続グラフ&lt;/strong> \(C(R)\) とは，\(R=(r,c)\), \(r=(r_1,\dots,r_n)\), \(c=(c_1,\dots,c_m)\), \(c_k=((i_1^k,i_2^k),((j_{11}^k,j_{12}^k),\dots,(j_{l_k1}^k,j_{l_k2}^k)))\ (1\le k\le m)\) のとき，\(V=\{v_1,v_2,\dots,v_n\}\), \(E=\{e_{11},\dots,e_{1l_1},e_{21},\dots,e_{2l_2},\dots,e_{m1},\dots,e_{ml_m}\}\) であり，\(g(e_{kl})=(v_{i_1^k},v_{i_2^k})\) による（一般に多重辺をもつ）有向グラフ \(C(R)=(V,E,g)\) のことである．&lt;/li>
&lt;/ol>
&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \(\)
&lt;/span>
&lt;/blockquote>
&lt;p>接続情報 &lt;span>
 \(c\in\Gamma_m\)
&lt;/span>
 はどのレール同士をどの端点で接続するかの情報を表します．&lt;span>
 \(c=(c_1,\dots,c_m)\)
&lt;/span>
, &lt;span>
 \(c_1=((i_1,i_2),((j_{11},j_{12}),\dots,(j_{l1},j_{l2})))\)
&lt;/span>
なら，&lt;span>
 \(c_1\)
&lt;/span>
 は，&lt;/p></description></item><item><title>差分プライバシの基本</title><link>https://htakeuchi0.github.io/docs/math/stat/dp/basic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/stat/dp/basic/</guid><description>&lt;h1 id="差分プライバシの基本">
 差分プライバシの基本
 &lt;a class="anchor" href="#%e5%b7%ae%e5%88%86%e3%83%97%e3%83%a9%e3%82%a4%e3%83%90%e3%82%b7%e3%81%ae%e5%9f%ba%e6%9c%ac">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>本ページでは，差分プライバシの基本事項についてまとめます．&lt;/p>
&lt;h2 id="準備">
 準備
 &lt;a class="anchor" href="#%e6%ba%96%e5%82%99">#&lt;/a>
&lt;/h2>
&lt;h3 id="記号定義">
 記号定義
 &lt;a class="anchor" href="#%e8%a8%98%e5%8f%b7%e5%ae%9a%e7%be%a9">#&lt;/a>
&lt;/h3>
&lt;p>&lt;span>
 \(\Omega\)
&lt;/span>
 を集合，&lt;span>
 \(\mathfrak{F}\subseteq 2^\Omega\)
&lt;/span>
, &lt;span>
 \(P:\mathfrak{F}\to\mathbb{R}\)
&lt;/span>
 とし，&lt;span>
 \((\Omega,\mathfrak{F},P)\)
&lt;/span>
 を確率空間とします．&lt;/p>
&lt;p>&lt;span>
 \(X:(\Omega,\mathfrak{F})\to(\mathbb{R}^{k},\mathfrak{B}(\mathbb{R}^{k}))\)
&lt;/span>
 を確率変数としたとき，&lt;span>
 \(S\in\mathfrak{B}(\mathbb{R}^{k})\)
&lt;/span>
 について &lt;span>
 \([X\in S]\)
&lt;/span>
 を
&lt;span>
 \[
 [X\in S]=\{\omega\in\Omega\mid X(\omega)\in S\}
\]
&lt;/span>

で定め，&lt;span>
 \(P([X\in S])\)
&lt;/span>
 を &lt;span>
 \(P(X\in S)\)
&lt;/span>
 と略記します．ただし，&lt;span>
 \(\mathfrak{B}(\mathbb{R}^{k})\)
&lt;/span>
 とは，&lt;span>
 \(\mathbb{R}^{k}\)
&lt;/span>
 の開集合全体 &lt;span>
 \(\mathfrak{O}(\mathbb{R}^{k})\)
&lt;/span>
 について，&lt;span>
 \(\mathfrak{O}(\mathbb{R}^{k})\)
&lt;/span>
 を含む最小の完全加法族を表します．&lt;/p>
&lt;p>ふたつの確率空間 &lt;span>
 \((\Omega_1,\mathfrak{F}_1,P_1)\)
&lt;/span>
, &lt;span>
 \((\Omega_2,\mathfrak{F}_2,P_2)\)
&lt;/span>
 に対して，ふたつの確率変数 &lt;span>
 \(X:(\Omega_1,\mathfrak{F}_1)\to(\mathbb{R}^{k},\mathfrak{B}(\mathbb{R}^{k}))\)
&lt;/span>
, &lt;span>
 \(Y:(\Omega_2,\mathfrak{F}_2)\to(\mathbb{R}^{k},\mathfrak{B}(\mathbb{R}^{k}))\)
&lt;/span>
 があったとき，&lt;span>
 \(P_1(X\in S)\)
&lt;/span>
, &lt;span>
 \(P_2(Y\in S)\)
&lt;/span>
 と書くべきところを，&lt;span>
 \(P(X\in S)\)
&lt;/span>
, &lt;span>
 \(P(Y\in S)\)
&lt;/span>
 と略記します．&lt;/p></description></item><item><title>指数関数の定積分：正規分布の累積分布関数の計算への応用</title><link>https://htakeuchi0.github.io/docs/math/exp_normal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/exp_normal/</guid><description>&lt;h1 id="指数関数の定積分正規分布の累積分布関数の計算への応用">
 指数関数の定積分：正規分布の累積分布関数の計算への応用
 &lt;a class="anchor" href="#%e6%8c%87%e6%95%b0%e9%96%a2%e6%95%b0%e3%81%ae%e5%ae%9a%e7%a9%8d%e5%88%86%e6%ad%a3%e8%a6%8f%e5%88%86%e5%b8%83%e3%81%ae%e7%b4%af%e7%a9%8d%e5%88%86%e5%b8%83%e9%96%a2%e6%95%b0%e3%81%ae%e8%a8%88%e7%ae%97%e3%81%b8%e3%81%ae%e5%bf%9c%e7%94%a8">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://htakeuchi0.github.io/docs/math/exp/">指数関数の定積分&lt;/a> のページでは，指数関数に関するいくつかの定積分の表示について説明しました．本ページでは，その応用として，正規分布の累積分布関数の計算への応用について説明します．&lt;/p>
&lt;p>例えば，C++17 では，標準ライブラリに &lt;code>std::erfc&lt;/code> 関数（相補誤差関数）がありますが，正規分布の累積分布関数を直接計算する関数は提供されていません．&lt;/p>
&lt;p>しかし，相補誤差関数と正規分布の累積分布関数はスケールが異なるだけなので，&lt;code>std::erfc&lt;/code> 関数があれば，正規分布の累積分布関数は計算できます．&lt;/p>
&lt;p>そこで，本ページでは，&lt;a href="https://htakeuchi0.github.io/docs/math/exp/">指数関数の定積分&lt;/a> の結果を用いて，相補誤差関数と正規分布の累積分布関数の具体的な関係式を導出します．&lt;/p>
&lt;h2 id="正規分布">
 正規分布
 &lt;a class="anchor" href="#%e6%ad%a3%e8%a6%8f%e5%88%86%e5%b8%83">#&lt;/a>
&lt;/h2>
&lt;p>&lt;strong>正規分布&lt;/strong> とは，連続型確率変数のしたがう確率分布のひとつで，様々な場面で用いられます．&lt;/p>
&lt;p>平均 &lt;span>
 \(\mu\)
&lt;/span>
, 分散 &lt;span>
 \(\sigma^2\)
&lt;/span>
 の正規分布の &lt;strong>確率密度関数&lt;/strong> は，
&lt;span>
 \[
f_X(x)=\frac{1}{\sqrt{2\pi\sigma^2}}\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)
\]
&lt;/span>

と表されます．
ここで，
&lt;span>
 \[
F_X(x)=\int_{-\infty}^xf_X(x)dx
\]
&lt;/span>

とおくと，&lt;span>
 \(F_X(x)\)
&lt;/span>
 は，正規分布に従う確率変数 &lt;span>
 \(X\)
&lt;/span>
 が &lt;span>
 \(x\)
&lt;/span>
 以下である確率を表します．
一般に，確率密度関数 &lt;span>
 \(f_X\)
&lt;/span>
を用いて上記の &lt;span>
 \(F_X\)
&lt;/span>
 のように定義される関数を &lt;strong>累積分布関数&lt;/strong> と呼びます．&lt;/p>
&lt;h2 id="正規分布の累積分布関数と誤差関数">
 正規分布の累積分布関数と誤差関数
 &lt;a class="anchor" href="#%e6%ad%a3%e8%a6%8f%e5%88%86%e5%b8%83%e3%81%ae%e7%b4%af%e7%a9%8d%e5%88%86%e5%b8%83%e9%96%a2%e6%95%b0%e3%81%a8%e8%aa%a4%e5%b7%ae%e9%96%a2%e6%95%b0">#&lt;/a>
&lt;/h2>
&lt;p>いま，
&lt;span>
 \[
-\frac{(x-\mu)^2}{2\sigma^2}=-\frac{1}{2\sigma^2}x^2+\frac{\mu}{\sigma^2}x-\frac{\mu^2}{2\sigma^2}
\]
&lt;/span>

なので，
&lt;span>
 \[
\begin{aligned}
 &amp;a=-\frac{1}{2\sigma^2},\\
 &amp;b=\frac{\mu}{\sigma^2},\\
 &amp;c=-\frac{\mu^2}{2\sigma^2}
\end{aligned}
\]
&lt;/span>

として，&lt;a href="https://htakeuchi0.github.io/docs/math/exp/#定積分3">指数関数の定積分の定積分3&lt;/a>を適用すると，
&lt;span>
 \[
\begin{aligned}
&amp;\frac{\sqrt{\pi}}{2\sqrt{-a}}=\frac{\sqrt{\pi}}{2\sqrt{1/(2\sigma^2)}}
=\frac{\sqrt{\pi}\sqrt{\sigma^2}}{\sqrt{2}},\\
&amp;\frac{b^2-4ac}{4a}=\frac{b^2}{4a}-c=\frac{\mu^2/\sigma^4}{-2/\sigma^2}-\left(-\frac{\mu^2}{2\sigma^2}\right)=0\\
&amp;\frac{b}{2a}
=\frac{\mu/\sigma^2}{-1/\sigma^2}
=-\mu
\end{aligned}
\]
&lt;/span>

より，
&lt;span>
 \[
\begin{aligned}
&amp;\int_{\alpha}^{\beta}\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)dx\\
&amp;=\frac{\sqrt{\pi}\sqrt{\sigma^2}}{\sqrt{2}}\\
&amp;\quad\times\left(\mathrm{erfc}\left(\frac{1}{\sqrt{2\sigma^2}}(\alpha-\mu)\right)-\mathrm{erfc}\left(\frac{1}{\sqrt{2\sigma^2}}(\beta-\mu)\right)\right)
\end{aligned}
\]
&lt;/span>

となります．特に，&lt;span>
 \(\beta=x\)
&lt;/span>
, &lt;span>
 \(\alpha\to-\infty\)
&lt;/span>
 のとき，
&lt;span>
 \[
\begin{aligned}
&amp;\int_{-\infty}^x\exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)dx\\
&amp;=\frac{\sqrt{\pi}\sqrt{\sigma^2}}{\sqrt{2}}\left(2-\mathrm{erfc}\left(\frac{1}{\sqrt{2\sigma^2}}(x-\mu)\right)\right)
\end{aligned}
\]
&lt;/span>

です．&lt;/p></description></item><item><title>行列積の計算時間のOpenMPによる高速化</title><link>https://htakeuchi0.github.io/docs/cpp/mmul/openmp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/mmul/openmp/</guid><description>&lt;h1 id="行列積の計算時間のopenmpによる高速化">
 行列積の計算時間のOpenMPによる高速化
 &lt;a class="anchor" href="#%e8%a1%8c%e5%88%97%e7%a9%8d%e3%81%ae%e8%a8%88%e7%ae%97%e6%99%82%e9%96%93%e3%81%aeopenmp%e3%81%ab%e3%82%88%e3%82%8b%e9%ab%98%e9%80%9f%e5%8c%96">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>OpenMP とは，並列計算機環境において，共有メモリ・マルチスレッド型の並列アプリケーションソフトウェア開発をサポートするために標準化されたAPIです．&lt;/p>
&lt;p>gcc コンパイラは OpenMP に対応しているため，ソースコード内に既定のキーワードを書けば，OpenMP による並列処理ができます．&lt;/p>
&lt;p>本ページでは，&lt;a href="https://htakeuchi0.github.io/docs/cpp/mmul/basic/">前ページ&lt;/a> の結果に対し，OpenMP を用いることで，行列積演算の実行時間が短縮できることを確認します．&lt;/p>
&lt;p>実験用に使ったプログラムは以下に配置しています．&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/htakeuchi0/mmul-gcc-sample">https://github.com/htakeuchi0/mmul-gcc-sample&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="openmp-の利用">
 OpenMP の利用
 &lt;a class="anchor" href="#openmp-%e3%81%ae%e5%88%a9%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;p>生の2次元配列で行列を表現する方式 (&lt;code>mdim_raw_array&lt;/code>) は，以下の実装としています．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> const_val&lt;span style="color:#f92672">::&lt;/span>kSize; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> const_val&lt;span style="color:#f92672">::&lt;/span>kSize; j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> cij &lt;span style="color:#f92672">=&lt;/span> c_[i][j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; k &lt;span style="color:#f92672">&amp;lt;&lt;/span> const_val&lt;span style="color:#f92672">::&lt;/span>kSize; k&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cij &lt;span style="color:#f92672">+=&lt;/span> a_[i][k] &lt;span style="color:#f92672">*&lt;/span> b_[k][j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>OpenMP を利用する場合，以下のようにします．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">double&lt;/span> cij &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#pragma omp parallel for private(j, k, cij)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> const_val&lt;span style="color:#f92672">::&lt;/span>kSize; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> const_val&lt;span style="color:#f92672">::&lt;/span>kSize; j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cij &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (k &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; k &lt;span style="color:#f92672">&amp;lt;&lt;/span> const_val&lt;span style="color:#f92672">::&lt;/span>kSize; k&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cij &lt;span style="color:#f92672">+=&lt;/span> a_[i][k] &lt;span style="color:#f92672">*&lt;/span> b_[k][j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c_[i][j] &lt;span style="color:#f92672">=&lt;/span> cij;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>OpenMP に関する補足は以下のとおりです．&lt;/p></description></item><item><title>配列への参照</title><link>https://htakeuchi0.github.io/docs/cpp/arrp/arr_ref/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/arrp/arr_ref/</guid><description>&lt;h1 id="配列への参照">
 配列への参照
 &lt;a class="anchor" href="#%e9%85%8d%e5%88%97%e3%81%b8%e3%81%ae%e5%8f%82%e7%85%a7">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>前ページまでで，配列へのポインタ，特に配列型へのポインタ型について説明しました．ここで，配列型へのポインタ型とは，そのポインタ型の変数に対して &lt;code>*&lt;/code> 演算子で値を得ると，要素ではなく，配列そのものが得られるようなポインタ型を指すものとします．本ページでは，配列型への参照型について説明します．&lt;/p>
&lt;h2 id="配列型への参照型">
 配列型への参照型
 &lt;a class="anchor" href="#%e9%85%8d%e5%88%97%e5%9e%8b%e3%81%b8%e3%81%ae%e5%8f%82%e7%85%a7%e5%9e%8b">#&lt;/a>
&lt;/h2>
&lt;p>クラス &lt;code>T&lt;/code> の要素数 &lt;code>N&lt;/code> の配列型へのポインタ変数 &lt;code>p_arr&lt;/code> の宣言は，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> p_arr_t &lt;span style="color:#f92672">=&lt;/span> T (&lt;span style="color:#f92672">*&lt;/span>)[N];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>または，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> arr_t &lt;span style="color:#f92672">=&lt;/span> T[N];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> p_arr_t &lt;span style="color:#f92672">=&lt;/span> arr_t &lt;span style="color:#f92672">*&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>として定義できるのでした．&lt;/p>
&lt;p>ここで，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> arr_ref_t &lt;span style="color:#f92672">=&lt;/span> T (&lt;span style="color:#f92672">&amp;amp;&lt;/span>)[N];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>または，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> arr_t &lt;span style="color:#f92672">=&lt;/span> T[N];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> arr_ref_t &lt;span style="color:#f92672">=&lt;/span> arr_t&lt;span style="color:#f92672">&amp;amp;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>とすると，&lt;strong>配列型への参照型&lt;/strong> をつくることができます．&lt;/p>
&lt;p>これを利用すると，前ページで説明した &lt;code>ArraySize&lt;/code> 関数テンプレートを参照型で定義できるため，呼び出し側で &lt;code>&amp;amp;&lt;/code> をつけずに利用できるようになります．&lt;/p>
&lt;p>具体的には，以下のようにできます．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstddef&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>size_t N&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>size_t ArraySize(T (&lt;span style="color:#f92672">&amp;amp;&lt;/span>)[N]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> N;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> arr[&lt;span style="color:#ae81ff">100&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> ArraySize(arr) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// 100
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> arr2[&lt;span style="color:#ae81ff">1024&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> ArraySize(arr2) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// 1024
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="まとめ">
 まとめ
 &lt;a class="anchor" href="#%e3%81%be%e3%81%a8%e3%82%81">#&lt;/a>
&lt;/h2>
&lt;p>本ページでは，配列型への参照型が定義できることを説明しました．配列型へのポインタ型でなく，配列型への参照型を利用すると，前ページの &lt;code>ArraySize&lt;/code> 関数テンプレートの呼び出し方を，少しだけ簡単にできます．&lt;/p></description></item><item><title>autoconf プロジェクト (2)</title><link>https://htakeuchi0.github.io/docs/cpp/env/autoconf2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/env/autoconf2/</guid><description>&lt;h1 id="autoconf-プロジェクト-2">
 autoconf プロジェクト (2)
 &lt;a class="anchor" href="#autoconf-%e3%83%97%e3%83%ad%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88-2">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>前ページでは，autoconf を使った Makefile の自動生成について説明しましたが，Makefile.am は main と test ディレクトリだけに配置し，subdir-objects オプションを使いました．&lt;/p>
&lt;p>autoconf では，各ディレクトリに Makefile.am を配置するのが通常と思いますので，その方針で設定をし直します．&lt;/p>
&lt;p>ただし，ディレクトリをまたいだソースコードをまとめてビルドできないので， &lt;strong>srcディレクトリ以下はライブラリとしてビルドし，main, test ではそのライブラリをリンクしてビルドします．&lt;/strong>&lt;/p>
&lt;p>その場合は，Libtool を利用したライブラリ生成が必要になるので，順を追って説明するために，前ページではそのようにしませんでした．&lt;/p>
&lt;p>本ページでは，Libtool を利用して，各ディレクトリに Makefile.am を配置して Makefile を生成する方法を説明します．&lt;/p>
&lt;h2 id="準備">
 準備
 &lt;a class="anchor" href="#%e6%ba%96%e5%82%99">#&lt;/a>
&lt;/h2>
&lt;p>今回も &lt;a href="https://htakeuchi0.github.io/docs/cpp/env/make/">Makefile プロジェクト&lt;/a> のリポジトリからスタートします． &lt;br>
初期状態のディレクトリ構成は以下のとおりです．&lt;/p>
&lt;pre tabindex="0">&lt;code>|- cpp_env_sample/
 |- Doxyfile - doxygen設定ファイル
 |- LICENSE - ライセンスファイル
 |- Makefile - makeファイル
 |- README.md - READMEファイル
 |- include/ - ヘッダファイル
 | |- cpp_env_sample/
 | |- example.h
 |
 |- main/ - メインファイル
 | |- main.cc
 |
 |- scripts/ - 環境構築用スクリプト
 | |- install_doxygen.sh
 | |- install_gtest.sh
 | |- install_lcov.sh
 |
 |- src/ - ソースファイル
 | |- example.cc
 |
 |- test/ - テストファイル
 |- gtest_example.cc
&lt;/code>&lt;/pre>&lt;p>まず，これから自動生成する Makefile を削除しておきます．&lt;/p></description></item><item><title>std::array について</title><link>https://htakeuchi0.github.io/docs/cpp/arrp/stdarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/arrp/stdarray/</guid><description>&lt;h1 id="stdarray-について">
 std::array について
 &lt;a class="anchor" href="#stdarray-%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>前ページまでで，配列型へのポインタ型や参照型について説明しました．一方で，標準ライブラリには &lt;code>std::array&lt;/code> 構造体テンプレートがあり，通常の配列のパフォーマンスを保ったまま，サイズの取得などの付随的な機能を利用できます．&lt;/p>
&lt;h2 id="stdarray-について-1">
 std::array について
 &lt;a class="anchor" href="#stdarray-%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6-1">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>array&lt;/code> ヘッダを include すると，&lt;code>std::array&lt;/code> が利用できます．
&lt;code>std::array&lt;/code> の定義は以下のとおりです &lt;a href="#cite:1">[1]&lt;/a>．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">namespace&lt;/span> std {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>size_t N&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">array&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#75715e">// namespace std
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>std::array&lt;/code> は通常の配列と同等のパフォーマンスで利用できるとされています．通常の配列と異なり，以下のように，変数から配列のサイズが取得できます．よって，&lt;code>std::array&lt;/code> を使う限り，&lt;strong>前ページで定義した &lt;code>ArraySize&lt;/code> は不要です&lt;/strong>．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;array&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>array&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> a.size() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// 3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="まとめ">
 まとめ
 &lt;a class="anchor" href="#%e3%81%be%e3%81%a8%e3%82%81">#&lt;/a>
&lt;/h2>
&lt;p>本ページでは，&lt;code>std::array&lt;/code> について説明しました．&lt;code>std::array&lt;/code> を使えば，配列から要素数を取得できます．よって，&lt;code>std::array&lt;/code> を使う限り，前ページで定義した &lt;code>ArraySize&lt;/code> 関数テンプレートは不要になります．&lt;/p>
&lt;h2 id="参考文献">
 参考文献
 &lt;a class="anchor" href="#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a id="cite:1">&lt;/a>
[1] cppreference.com, &amp;ldquo;std::array - cppreference.com&amp;rdquo;, &lt;a href="https://en.cppreference.com/w/cpp/container/array">https://en.cppreference.com/w/cpp/container/array&lt;/a>, 2022/8/21 最終アクセス.&lt;/p></description></item><item><title>std::function とその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/fp/stdfunc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/stdfunc/</guid><description>&lt;h1 id="stdfunction-とその周辺">
 std::function とその周辺
 &lt;a class="anchor" href="#stdfunction-%e3%81%a8%e3%81%9d%e3%81%ae%e5%91%a8%e8%be%ba">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>前ページまでは，関数ポインタやメンバ関数ポインタについて説明しました．本ページでは，標準ライブラリ &lt;code>std::function&lt;/code> を利用する方法について説明します．&lt;/p>
&lt;p>実用上は &lt;code>std::function&lt;/code> を使う方法で十分と思います．&lt;/p>
&lt;h2 id="stdfunction-について">
 std::function について
 &lt;a class="anchor" href="#stdfunction-%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>functional&lt;/code> ヘッダを include すると，&lt;code>std::function&lt;/code> が利用できます．
&lt;code>std::function&lt;/code> の定義は以下のとおりです &lt;a href="#cite:1">[1]&lt;/a>．
テンプレートクラスですが，テンプレートの特殊化によって，関数型のみが受け付けられるようになっています．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">function&lt;/span>; &lt;span style="color:#75715e">/* undefined */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">R&lt;/span>, &lt;span style="color:#66d9ef">class&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">... &lt;/span>&lt;span style="color:#a6e22e">Args&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">function&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>R(Args...)&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>まず，&lt;code>Args...&lt;/code> は可変テンプレート引数の型を表します．
よって，&lt;code>R(Args...)&lt;/code> は 戻り値の型が &lt;code>R&lt;/code> で，引数の型が &lt;code>Args...&lt;/code> である関数の型です．
したがって，&lt;code>Newton&lt;/code> 関数を以下のように定義しておけば，&lt;code>f&lt;/code>, &lt;code>df&lt;/code> は関数を渡せます．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;functional&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> func_t &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>function&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">double&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span>)&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">Newton&lt;/span>(func_t f, func_t df, &lt;span style="color:#66d9ef">double&lt;/span> x0, &lt;span style="color:#66d9ef">double&lt;/span> eps&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1.0e-10&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>size_t loop_max&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1024&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> x0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>size_t i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> loop_max; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">-=&lt;/span> f(x) &lt;span style="color:#f92672">/&lt;/span> df(x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>abs(f(x)) &lt;span style="color:#f92672">&amp;lt;&lt;/span> eps) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>runtime_error(&lt;span style="color:#e6db74">&amp;#34;Convergence error: This method did not converge.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>たとえば，&lt;/p></description></item><item><title>サイコロをN回投げたときおよそ6回に1回程度の割合で1の目が出ることの確認</title><link>https://htakeuchi0.github.io/docs/math/stat/dice/dice_approx_ratio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/stat/dice/dice_approx_ratio/</guid><description>&lt;h1 id="サイコロをn回投げたときおよそ6回に1回程度の割合で1の目が出ることの確認">
 サイコロをN回投げたときおよそ6回に1回程度の割合で1の目が出ることの確認
 &lt;a class="anchor" href="#%e3%82%b5%e3%82%a4%e3%82%b3%e3%83%ad%e3%82%92n%e5%9b%9e%e6%8a%95%e3%81%92%e3%81%9f%e3%81%a8%e3%81%8d%e3%81%8a%e3%82%88%e3%81%9d6%e5%9b%9e%e3%81%ab1%e5%9b%9e%e7%a8%8b%e5%ba%a6%e3%81%ae%e5%89%b2%e5%90%88%e3%81%a71%e3%81%ae%e7%9b%ae%e3%81%8c%e5%87%ba%e3%82%8b%e3%81%93%e3%81%a8%e3%81%ae%e7%a2%ba%e8%aa%8d">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>サイコロを繰り返し投げると，およそ6回に1回程度の割合で1の目が出ることを確認したいと思いますが，&lt;strong>ちょうど&lt;/strong>6回に1回の割合で出るわけではないことがわかりました．&lt;/p>
&lt;p>そこで，本ページでは，&lt;strong>およそ&lt;/strong>6回に1回&lt;strong>程度&lt;/strong>の割合で出ることを確認する方法を考えます．&lt;/p>
&lt;p>いま，
&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \(p(N,k)=\binom{N}{k}5^{N-k}/6^N\)
&lt;/span>
とします．&lt;/p>
&lt;p>このとき，以下の方針が考えられます．&lt;/p>
&lt;ol>
&lt;li>&lt;span>
 \(p(N,k)\)
&lt;/span>
が最大となる&lt;span>
 \(k\)
&lt;/span>
が，およそ&lt;span>
 \(N/6\)
&lt;/span>
であることを確認する．&lt;/li>
&lt;li>サイコロを繰り返し投げると，平均的に&lt;span>
 \(N/6\)
&lt;/span>
程度の回数だけ1の目が出ることを確認する．&lt;/li>
&lt;/ol>
&lt;p>1は，&lt;span>
 \(N\)
&lt;/span>
を固定したとき，1の目が出る回数として最もあり得るのがおよそ&lt;span>
 \(N/6\)
&lt;/span>
 のときであることを確認する方針です．&lt;/p>
&lt;p>2は，サイコロを &lt;span>
 \(N\)
&lt;/span>
投げる試行自体を繰り返すと，試行ごとにばらつきがあるが，平均的には &lt;span>
 \(N/6\)
&lt;/span>
 回程度1の目が出ることを確認する方針です．&lt;/p>
&lt;h2 id="確率が最大となる1の目の出る回数がn6程度であることの確認">
 確率が最大となる1の目の出る回数がN/6程度であることの確認
 &lt;a class="anchor" href="#%e7%a2%ba%e7%8e%87%e3%81%8c%e6%9c%80%e5%a4%a7%e3%81%a8%e3%81%aa%e3%82%8b1%e3%81%ae%e7%9b%ae%e3%81%ae%e5%87%ba%e3%82%8b%e5%9b%9e%e6%95%b0%e3%81%8cn6%e7%a8%8b%e5%ba%a6%e3%81%a7%e3%81%82%e3%82%8b%e3%81%93%e3%81%a8%e3%81%ae%e7%a2%ba%e8%aa%8d">#&lt;/a>
&lt;/h2>
&lt;p>まず，&lt;span>
 \(p(N,k)\)
&lt;/span>
 を数値的に計算してみます．&lt;span>
 \(N=10,100,1000\)
&lt;/span>
 の場合を計算しますが，値が小さくなりすぎるので，&lt;span>
 \(\log_{10}p(N,k)\)
&lt;/span>
 を計算することにします．&lt;/p>
&lt;p>縦軸・横軸のスケールが各グラフで異なる点に注意してください．&lt;/p>
&lt;p>&lt;figure class="text-center">&lt;img src="https://htakeuchi0.github.io/images/docs/math/stat/dice/dice_plot-1.png">&lt;figcaption>
 &lt;h4>Figure 1. N=10の場合&lt;/h4>
 &lt;/figcaption>
&lt;/figure>

&lt;figure class="text-center">&lt;img src="https://htakeuchi0.github.io/images/docs/math/stat/dice/dice_plot-2.png">&lt;figcaption>
 &lt;h4>Figure 2. N=100の場合&lt;/h4>
 &lt;/figcaption>
&lt;/figure>

&lt;figure class="text-center">&lt;img src="https://htakeuchi0.github.io/images/docs/math/stat/dice/dice_plot-3.png">&lt;figcaption>
 &lt;h4>Figure 3. N=1000の場合&lt;/h4>
 &lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>Figs. 1&amp;ndash;3 より，&lt;span>
 \(k=k_0\)
&lt;/span>
 で &lt;span>
 \(p(N,k)\)
&lt;/span>
 が最大になるとき，&lt;span>
 \(k&lt;k_0\)
&lt;/span>
 の範囲では &lt;span>
 \(p(N,k)\)
&lt;/span>
 は大きくなり，&lt;span>
 \(k>k_0\)
&lt;/span>
 の範囲では，&lt;span>
 \(p(N,k)\)
&lt;/span>
 は小さくなるようです．よって，この頂点となる &lt;span>
 \(k=k_0\)
&lt;/span>
 が &lt;span>
 \(N/6\)
&lt;/span>
 程度だとわかればよさそうです．&lt;/p></description></item><item><title>プラレール問題</title><link>https://htakeuchi0.github.io/docs/math/plarail/plarail-problems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/plarail/plarail-problems/</guid><description>&lt;h1 id="プラレール問題">
 プラレール問題
 &lt;a class="anchor" href="#%e3%83%97%e3%83%a9%e3%83%ac%e3%83%bc%e3%83%ab%e5%95%8f%e9%a1%8c">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>タカラトミーのプラレールという鉄道玩具が広く知られています &lt;a href="#takaratomy:1">[1]&lt;/a>．前ページまでで，&lt;a href="https://htakeuchi0.github.io/docs/math/plarail/rail/">レール&lt;/a> と &lt;a href="https://htakeuchi0.github.io/docs/math/plarail/layout/">レイアウト&lt;/a> の形式的定義について述べました．本ページでは，レールとレイアウトに関するどのような問題が考えられるかについて述べます．&lt;/p>
&lt;h2 id="プラレール問題-1">
 プラレール問題
 &lt;a class="anchor" href="#%e3%83%97%e3%83%a9%e3%83%ac%e3%83%bc%e3%83%ab%e5%95%8f%e9%a1%8c-1">#&lt;/a>
&lt;/h2>
&lt;p>プラレールに関する問題について考えます．
通常，手元にあるレールは有限です．もう少し正確にいうと，有限種類のレールが有限個ずつあるのが普通です．レールは接続ができればどの向きにおいても裏返しても構わないのでした．&lt;/p>
&lt;p>問題の定式化を考える前に，まず準備として記号の定義を追加します．&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;b>Definition 1&lt;/b>.
\(\sigma\) を \(\mathbb{R}^3\) 上の直交変換とする．&lt;/p>
&lt;ol>
&lt;li>\(\phi\in\Phi\) に対して \(\phi^\sigma\) を，\(\phi^\sigma(\theta)=\phi(\theta)^\sigma,(0&amp;lt;\theta&amp;lt;1)\) で定める．&lt;/li>
&lt;li>レール \(r=(\phi_1,\dots,\phi_n,t_1,\dots,t_m,\psi,u_1,\dots,u_{n-1})\in\mathcal{R}\) に対して \(r^\sigma\) を，\(r^\sigma=(\phi^\sigma_1,\dots,\phi^\sigma_n,t_1,\dots,t_m,\psi,u_1^\sigma,\dots,u_{n-1}^\sigma)\) で定める．&lt;/li>
&lt;/ol>
&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \(\)
&lt;/span>
&lt;/blockquote>
&lt;p>&lt;span>
 \(\sigma\)
&lt;/span>
 は3次元空間上の回転を表すので，これはレールの回転を表すための記号です．&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;b>Definition 2&lt;/b>.
\(N\) を1以上の整数とし，\(r_1,\dots,r_N\) をレール，\(n_1,\dots,n_N\) を1以上の整数とする．レイアウト \(R=(r'_1,\dots,r'_n,c_1,\dots,c_m)\) について，各 \(i=1,2,\dots,n\) について，\(j_i\) と，ある \(\mathbb{R}^3\) 上の直交変換 \(\sigma_i\) が存在し，\(r'_i=r_{j_i}^{\sigma_i}\) であり，\(|\{j\mid \exists \sigma\,(r_i={r'_j}^\sigma\}|\le n_i\) であるとき，レイアウト \(R\) は \(r'_1,\dots,r'_n,c_1,\dots,c_m\) で &lt;strong>実現可能&lt;/strong> であるといい，このレイアウト全体を \(\mathcal{A}_{r_1,\dots,r_N,n_1,\dots,n_N}\) で表す．&lt;/p>
&lt;/blockquote>
&lt;p>実現可能という定義は，手元のレールセットでレイアウトが組めるものを指します．&lt;/p></description></item><item><title>ラプラス分布や切断ラプラス分布からのサンプリング</title><link>https://htakeuchi0.github.io/docs/math/stat/lap/sampling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/stat/lap/sampling/</guid><description>&lt;h1 id="ラプラス分布や切断ラプラス分布からのサンプリング">
 ラプラス分布や切断ラプラス分布からのサンプリング
 &lt;a class="anchor" href="#%e3%83%a9%e3%83%97%e3%83%a9%e3%82%b9%e5%88%86%e5%b8%83%e3%82%84%e5%88%87%e6%96%ad%e3%83%a9%e3%83%97%e3%83%a9%e3%82%b9%e5%88%86%e5%b8%83%e3%81%8b%e3%82%89%e3%81%ae%e3%82%b5%e3%83%b3%e3%83%97%e3%83%aa%e3%83%b3%e3%82%b0">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://htakeuchi0.github.io/docs/math/stat/lap/trunclap/">ラプラス分布と切断ラプラス分布&lt;/a> のページでは，ラプラス分布と切断ラプラス分布の定義を述べ，切断ラプラス分布の確率密度関数，累積分布関数を具体的に求めました．&lt;/p>
&lt;p>本ページでは，ラプラス分布や切断ラプラス分布からのサンプリングの方法について述べます．&lt;/p>
&lt;h2 id="逆関数法">
 逆関数法
 &lt;a class="anchor" href="#%e9%80%86%e9%96%a2%e6%95%b0%e6%b3%95">#&lt;/a>
&lt;/h2>
&lt;p>指定した分布に従う乱数をサンプリングする方法として，&lt;strong>逆関数法&lt;/strong> と呼ばれる方法が知られています．&lt;/p>
&lt;p>ラプラス分布や切断ラプラス分布に従う乱数を，この方法で生成することを考えます．まずは，逆関数法についてまとめます．
本節の議論は，ラプラス分布や切断ラプラス分布に限らず適用できます．&lt;/p>
&lt;p>
&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \(X\)
&lt;/span>
 を確率変数とし，&lt;span>
 \(F_X\)
&lt;/span>
 を &lt;span>
 \(X\)
&lt;/span>
の累積分布関数とします．
&lt;span>
 \(F_X\)
&lt;/span>
 は単調増加関数です．
&lt;span>
 \(F_X^*:[0,1]\to\mathbb{R}\)
&lt;/span>
 を，&lt;span>
 \(F_X^*(u)=\inf\{x\mid F(x)\ge u\}\)
&lt;/span>
 とします&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>．
ここで，&lt;span>
 \(U\)
&lt;/span>
 を区間 &lt;span>
 \([0,1]\)
&lt;/span>
 上の一様分布とします．
つまり，
&lt;span>
 \[
 f_U(u)=\begin{cases}
 1,&amp; 0\le u\le 1,\\
 0,&amp;\text{otherwise}
 \end{cases}
\]
&lt;/span>

とします．
&lt;span>
 \(Z=F_X^*(U)\)
&lt;/span>
 とすると，
&lt;span>
 \[
\begin{aligned}
 F_Z(z)&amp;=P([Z\le z])\\
 &amp;=P([F^*_X(U)\le z])\\
\end{aligned}
\]
&lt;/span>

となりますが，&lt;span>
 \(F^*_X(u)\le z\)
&lt;/span>
 であることと &lt;span>
 \(u\le F_X(z)\)
&lt;/span>
 であることは同じことなので，
&lt;span>
 \[
\begin{aligned}
 F_Z(z)&amp;=P([F^*_X(U)\le z])\\
 &amp;=P([U\le F_X(z)])\\
 &amp;=F_U(F_X(z))\\
 &amp;=F_X(z)
\end{aligned}
\]
&lt;/span>

となり，&lt;span>
 \(Z\)
&lt;/span>
 の累積分布関数は &lt;span>
 \(X\)
&lt;/span>
 の累積分布関数に一致します．&lt;/p></description></item><item><title>公開用ファイルの生成</title><link>https://htakeuchi0.github.io/docs/hugo/genpages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/hugo/genpages/</guid><description>&lt;h1 id="公開用ファイルの生成">
 公開用ファイルの生成
 &lt;a class="anchor" href="#%e5%85%ac%e9%96%8b%e7%94%a8%e3%83%95%e3%82%a1%e3%82%a4%e3%83%ab%e3%81%ae%e7%94%9f%e6%88%90">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>本ページでは，Hugo で作成した markdown ファイルを公開用の html ファイルにビルドして，公開する方法について説明します．&lt;/p>
&lt;h2 id="htmlファイルの生成">
 htmlファイルの生成
 &lt;a class="anchor" href="#html%e3%83%95%e3%82%a1%e3%82%a4%e3%83%ab%e3%81%ae%e7%94%9f%e6%88%90">#&lt;/a>
&lt;/h2>
&lt;p>以下のコマンドを実行すると，&lt;code>public&lt;/code> ディレクトリ以下に公開用ファイル一式が生成されます．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ hugo --minify -D
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ページの公開">
 ページの公開
 &lt;a class="anchor" href="#%e3%83%9a%e3%83%bc%e3%82%b8%e3%81%ae%e5%85%ac%e9%96%8b">#&lt;/a>
&lt;/h2>
&lt;p>本サイトは，Github Pages &lt;a href="#cite:1">[1]&lt;/a> を利用してページを公開しています． &lt;br>
作者は，作成用ファイルと公開ファイルを &lt;strong>別リポジトリで管理しています&lt;/strong>．&lt;/p>
&lt;ul>
&lt;li>htakeuchi0.github.io リポジトリ：公開用&lt;/li>
&lt;li>htakeuchi0.github.io-sources リポジトリ：作成用&lt;/li>
&lt;/ul>
&lt;p>Hugo では &lt;a href="#cite:2">[2]&lt;/a> のように，同一リポジトリで別ブランチで管理する方法が説明されています．&lt;/p>
&lt;p>本サイトの管理方法の場合，&lt;code>htakeuchi0.github.io-sources&lt;/code> リポジトリ側で &lt;code>public&lt;/code> 以下に生成されたファイルすべてを，&lt;code>htakeuchi0.github.io&lt;/code> リポジトリに配置します．&lt;/p>
&lt;p>あとは，&lt;a href="#cite:1">[1]&lt;/a> のとおりに設定すれば，数分でブラウザからアクセスできるようになります．&lt;/p>
&lt;h2 id="google-search-console-の設定">
 Google Search Console の設定
 &lt;a class="anchor" href="#google-search-console-%e3%81%ae%e8%a8%ad%e5%ae%9a">#&lt;/a>
&lt;/h2>
&lt;p>Hugo では（少なくとも Book テーマでは），サイトマップ用の &lt;code>sitemap.xml&lt;/code> とRSS用の &lt;code>index.xml&lt;/code> が生成されているので，それぞれを Google Search Console &lt;a href="#cite:3">[3]&lt;/a> に登録するだけです．&lt;/p>
&lt;h2 id="まとめ">
 まとめ
 &lt;a class="anchor" href="#%e3%81%be%e3%81%a8%e3%82%81">#&lt;/a>
&lt;/h2>
&lt;p>本ページでは，公開ファイルを生成して，公開する方法について説明しました．&lt;/p>
&lt;h2 id="参考文献">
 参考文献
 &lt;a class="anchor" href="#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a id="cite:1">&lt;/a>
[1] Github, &amp;ldquo;About GitHub Pages - GitHub Docs&amp;rdquo;, &lt;a href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages">https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages&lt;/a>, 2022/8/12 最終アクセス． &lt;br>
&lt;a id="cite:2">&lt;/a>
[2] Hugo, &amp;ldquo;Host on GitHub | Hugo&amp;rdquo;, &lt;a href="https://gohugo.io/hosting-and-deployment/hosting-on-github/">https://gohugo.io/hosting-and-deployment/hosting-on-github/&lt;/a>, 2022/8/12 最終アクセス． &lt;br>
&lt;a id="cite:3">&lt;/a>
[3] Google, &amp;ldquo;Google Search Console へようこそ&amp;rdquo;, &lt;a href="https://search.google.com/search-console/welcome?hl=JA">https://search.google.com/search-console/welcome?hl=JA&lt;/a>, 2022/8/12最終アクセス．&lt;/p></description></item><item><title>特殊なラプラス分布や切断ラプラス分布のパラメータ推定</title><link>https://htakeuchi0.github.io/docs/math/stat/lap/mle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/stat/lap/mle/</guid><description>&lt;h1 id="特殊なラプラス分布や切断ラプラス分布のパラメータ推定">
 特殊なラプラス分布や切断ラプラス分布のパラメータ推定
 &lt;a class="anchor" href="#%e7%89%b9%e6%ae%8a%e3%81%aa%e3%83%a9%e3%83%97%e3%83%a9%e3%82%b9%e5%88%86%e5%b8%83%e3%82%84%e5%88%87%e6%96%ad%e3%83%a9%e3%83%97%e3%83%a9%e3%82%b9%e5%88%86%e5%b8%83%e3%81%ae%e3%83%91%e3%83%a9%e3%83%a1%e3%83%bc%e3%82%bf%e6%8e%a8%e5%ae%9a">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://htakeuchi0.github.io/docs/math/stat/lap/sampling/">前ページ&lt;/a> では，ラプラス分布や切断ラプラス分布からのサンプリングについてまとめました．&lt;/p>
&lt;p>本ページでは，ラプラス分布や切断ラプラス分布に従う乱数から，各分布のパラメータを推定する方法についてまとめます．&lt;/p>
&lt;p>ただし，本節は，簡易な直接計算でラプラス分布の性質を述べることを目的としているので，すべてのパラメータでなく，一部のパラメータのみを推定する場合を考えます．&lt;/p>
&lt;p>具体的には，
&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \(\mu\)
&lt;/span>
 は &lt;span>
 \(0\)
&lt;/span>
 に固定し，切断ラプラス分布では左右対称な分布となるケースのみを考えます．&lt;/p>
&lt;h2 id="mu0-であるラプラス分布のパラメータ推定">
 \(\mu=0\) であるラプラス分布のパラメータ推定
 &lt;a class="anchor" href="#mu0-%e3%81%a7%e3%81%82%e3%82%8b%e3%83%a9%e3%83%97%e3%83%a9%e3%82%b9%e5%88%86%e5%b8%83%e3%81%ae%e3%83%91%e3%83%a9%e3%83%a1%e3%83%bc%e3%82%bf%e6%8e%a8%e5%ae%9a">#&lt;/a>
&lt;/h2>
&lt;p>いま，&lt;span>
 \(X_1,X_2,\dots,X_N\)
&lt;/span>
 を，独立にパラメータ &lt;span>
 \(\mu,b\)
&lt;/span>
 のラプラス分布に従う確率変数とし，&lt;span>
 \(\mu=0\)
&lt;/span>
 とします．&lt;/p>
&lt;p>このとき，
&lt;span>
 \[
 f_{X_1,X_2,\dots,X_N}(x_1,x_2,\dots,x_N;b)=\prod_{i=1}^N\frac{1}{2b}\exp\left(-\frac{|x_i|}{b}\right)
\]
&lt;/span>

と表されます．
&lt;span>
 \(\mathcal{L}_{x_1,\dots,x_N}(b)=\log f_{X_1,X_2,\dots,X_N}(x_1,x_2,\dots,x_N;b)\)
&lt;/span>
 とおくと，
&lt;span>
 \[
\begin{aligned}
 \mathcal{L}_{x_1,\dots,x_N}(b)&amp;=\log\prod_{i=1}^N\frac{1}{2b}\exp\left(-\frac{|x_i|}{b}\right)\\
 &amp;=\sum_{i=1}^N\left(\log\frac{1}{2b}+\log\exp\left(-\frac{|x_i|}{b}\right)\right)\\
 &amp;=-N\log 2b-\frac{1}{b}\sum_{i=1}^N|x_i|
\end{aligned}
\]
&lt;/span>

となります．&lt;/p>
&lt;p>ここで，&lt;span>
 \(\mathcal{L}_{x_1,\dots,x_N}(b)\)
&lt;/span>
 が最大となるような &lt;span>
 \(b\)
&lt;/span>
 を求めます．
&lt;span>
 \[
\begin{aligned}
\frac{d\mathcal{L}_{x_1,\dots,x_N}}{db}(b)&amp;=-\frac{N}{b}+\frac{1}{b^2}\sum_{i=1}^N|x_i|\\
&amp;=-\frac{N}{b^2}\left(b-\frac{1}{N}\sum_{i=1}^N|x_i|\right),\\
\frac{d^2\mathcal{L}_{x_1,\dots,x_N}}{db^2}(b)&amp;=\frac{N}{b^2}-\frac{2}{b^3}\sum_{i=1}^N|x_i|\\
&amp;=\frac{N}{b^3}\left(b-\frac{2}{N}\sum_{i=1}^N|x_i|\right)
\end{aligned}
\]
&lt;/span>

なので，&lt;span>
 \(b=(1/N)\sum_{i=1}^N|x_i|\)
&lt;/span>
 とすると，&lt;span>
 \(d\mathcal{L}_{x_1,\dots,x_N}/db=0\)
&lt;/span>
, &lt;span>
 \(d^2\mathcal{L}_{x_1,\dots,x_N}/db^2=-(1/b^3)\sum_{i=1}^N|x_i|&lt;0\)
&lt;/span>
 なので，&lt;span>
 \(b=(1/N)\sum_{i=1}^N|x_i|\)
&lt;/span>
 で &lt;span>
 \(\mathcal{L}_{x_1,\dots,x_N}(b)\)
&lt;/span>
 は最大値をとります．&lt;/p></description></item><item><title>行列積の計算時間のCPU拡張命令による高速化</title><link>https://htakeuchi0.github.io/docs/cpp/mmul/avx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/mmul/avx/</guid><description>&lt;h1 id="行列積の計算時間のcpu拡張命令による高速化">
 行列積の計算時間のCPU拡張命令による高速化
 &lt;a class="anchor" href="#%e8%a1%8c%e5%88%97%e7%a9%8d%e3%81%ae%e8%a8%88%e7%ae%97%e6%99%82%e9%96%93%e3%81%aecpu%e6%8b%a1%e5%bc%b5%e5%91%bd%e4%bb%a4%e3%81%ab%e3%82%88%e3%82%8b%e9%ab%98%e9%80%9f%e5%8c%96">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://htakeuchi0.github.io/docs/cpp/mmul/openmp/">前ページ&lt;/a> では，OpenMP を用いることで，行列積演算の実行時間が短縮できることを確認しました．&lt;/p>
&lt;p>これは，直列に実行する処理を，並列に行うことで実行時間の短縮を図ったものですが，同様の効果を狙う別の方法として，SIMD (Single Instruction, Multiple Data) と呼ばれる方法があります．
これは，一つの命令を複数のデータに同時に適用することをいいます．&lt;/p>
&lt;p>この方法は，CPUの拡張命令を用いて実現できます．
Intel CPU では，Intel Intrinsics API という，CPUの命令セット拡張へのアクセスができるAPIを公開しています &lt;a href="#intel:1">[1]&lt;/a>．&lt;/p>
&lt;p>C++17 では，例えばヘッダファイル &lt;code>&amp;lt;immintrin.h&amp;gt;&lt;/code> をインクルードすることで，AVX2 という拡張機能が使え，コンパイル時に &lt;code>-march=native -mavx2&lt;/code> というフラグを追加すると，AVX2 による命令を実行するプログラムが作成できます．&lt;/p>
&lt;p>本ページでは，Intel CPU の拡張命令を用いて，SIMD により行列積演算の実行時間が短縮できることを確認します．&lt;/p>
&lt;p>実験用に使ったプログラムは以下に配置しています．&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/htakeuchi0/mmul-gcc-sample">https://github.com/htakeuchi0/mmul-gcc-sample&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="cpu拡張命令の利用">
 CPU拡張命令の利用
 &lt;a class="anchor" href="#cpu%e6%8b%a1%e5%bc%b5%e5%91%bd%e4%bb%a4%e3%81%ae%e5%88%a9%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;p>まず，実験用PCで，AVX2の命令が実行できるかを確かめます．
Ubutu 22.04.4 LTS の場合，以下のコマンドで確認ができます．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>$ grep -m &lt;span style="color:#ae81ff">1&lt;/span> -e &lt;span style="color:#e6db74">&amp;#34;^flags&amp;#34;&lt;/span> /proc/cpuinfo -e avx2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>flags : ...（略）... avx2 ...（略）...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>AVX2 は 256 ビットごとの演算ができます．
倍精度浮動小数点数は 64 ビットなので，1つの拡張命令を，
&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \(256/64=4\)
&lt;/span>
 個のデータに同時に適用できます．&lt;/p></description></item><item><title>autoconf プロジェクト (3)</title><link>https://htakeuchi0.github.io/docs/cpp/env/autoconf3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/env/autoconf3/</guid><description>&lt;h1 id="autoconf-プロジェクト-3">
 autoconf プロジェクト (3)
 &lt;a class="anchor" href="#autoconf-%e3%83%97%e3%83%ad%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88-3">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>前ページでは，Libtool を利用して，より自然な autoconf を使った Makefile の自動生成について説明しました．&lt;/p>
&lt;p>しかし，&lt;a href="https://htakeuchi0.github.io/docs/cpp/env/make/">Makefile プロジェクト&lt;/a> と比べると以下の点が不十分です．&lt;/p>
&lt;ol>
&lt;li>&lt;code>make clean&lt;/code> をしても &lt;code>*.gcno&lt;/code>, &lt;code>*.gcda&lt;/code> のファイルが残る&lt;/li>
&lt;li>&lt;code>make check&lt;/code> で Google Test の結果が表示されない&lt;/li>
&lt;li>&lt;code>make docs&lt;/code>, &lt;code>make lcov&lt;/code> が実行できない&lt;/li>
&lt;li>&lt;code>make lib&lt;/code> で共有ライブラリのビルドができない&lt;/li>
&lt;/ol>
&lt;p>本ページでは，これらを組み込む方法を説明します．その後，&amp;ldquo;その他&amp;rdquo; として，さらに不足している設定も説明します．&lt;/p>
&lt;h2 id="make-clean-をしたとき-gcno-gcda-のファイルを消すようにする">
 &lt;code>make clean&lt;/code> をしたとき &lt;code>*.gcno&lt;/code>, &lt;code>*.gcda&lt;/code> のファイルを消すようにする
 &lt;a class="anchor" href="#make-clean-%e3%82%92%e3%81%97%e3%81%9f%e3%81%a8%e3%81%8d-gcno-gcda-%e3%81%ae%e3%83%95%e3%82%a1%e3%82%a4%e3%83%ab%e3%82%92%e6%b6%88%e3%81%99%e3%82%88%e3%81%86%e3%81%ab%e3%81%99%e3%82%8b">#&lt;/a>
&lt;/h2>
&lt;p>本節では，&lt;code>make clean&lt;/code> をしたときに削除されないファイルがあることへの対処法を説明します．&lt;/p>
&lt;p>本プロジェクトの場合，削除されないファイルは &lt;code>src/*.gcno&lt;/code>, &lt;code>test/*.gcno&lt;/code>, &lt;code>test/*.gcda&lt;/code> ですが，これらファイルは &lt;code>make check&lt;/code> で使っている &lt;code>gcov&lt;/code> のカバレッジ計測用ファイルです．&lt;/p>
&lt;p>このように &amp;ldquo;ローカルルール&amp;rdquo; で生成されたファイルを消すには，&lt;strong>clean のローカルルールのようなものを定義してあげる必要があります&lt;/strong>．&lt;/p>
&lt;p>&lt;a href="https://htakeuchi0.github.io/docs/cpp/env/autoconf2//#makefileam-%e3%81%ae%e4%bd%9c%e6%88%90">前ページ&lt;/a> で，プロジェクトのルートディレクトリに以下のような &lt;code>Makefile.am&lt;/code> を用意しました．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Makefile" data-lang="Makefile">&lt;span style="display:flex;">&lt;span>SUBDIRS &lt;span style="color:#f92672">=&lt;/span> include src main test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ACLOCAL_AMFLAGS &lt;span style="color:#f92672">=&lt;/span> -I m4
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ここに以下のルールを追加します．&lt;/p></description></item><item><title>サイコロをN回投げたときおよそ6回に1回程度の割合で1の目が出ることの確率変数の導入による整理</title><link>https://htakeuchi0.github.io/docs/math/stat/dice/dice_randval/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/stat/dice/dice_randval/</guid><description>&lt;h1 id="サイコロをn回投げたときおよそ6回に1回程度の割合で1の目が出ることの確率変数の導入による整理">
 サイコロをN回投げたときおよそ6回に1回程度の割合で1の目が出ることの確率変数の導入による整理
 &lt;a class="anchor" href="#%e3%82%b5%e3%82%a4%e3%82%b3%e3%83%ad%e3%82%92n%e5%9b%9e%e6%8a%95%e3%81%92%e3%81%9f%e3%81%a8%e3%81%8d%e3%81%8a%e3%82%88%e3%81%9d6%e5%9b%9e%e3%81%ab1%e5%9b%9e%e7%a8%8b%e5%ba%a6%e3%81%ae%e5%89%b2%e5%90%88%e3%81%a71%e3%81%ae%e7%9b%ae%e3%81%8c%e5%87%ba%e3%82%8b%e3%81%93%e3%81%a8%e3%81%ae%e7%a2%ba%e7%8e%87%e5%a4%89%e6%95%b0%e3%81%ae%e5%b0%8e%e5%85%a5%e3%81%ab%e3%82%88%e3%82%8b%e6%95%b4%e7%90%86">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>前ページまでで，サイコロを &lt;span>
 \(N\)
&lt;/span>
回投げるとき，次が成り立つことがわかりました．&lt;/p>
&lt;ul>
&lt;li>確率が最大となる1の目の出る回数は &lt;span>
 \(N/6\)
&lt;/span>
程度である&lt;/li>
&lt;li>平均的に&lt;span>
 \(N/6\)
&lt;/span>
回程度，1の目が出る&lt;/li>
&lt;/ul>
&lt;p>しかし，もとの“およそ6回に1回程度の割合で1の目が出る”という主張に対して，平均といった概念をもちだしているなど，直接的な結果に感じません．&lt;/p>
&lt;p>そこで本ページでは，&lt;strong>確率変数&lt;/strong>を導入することで，この問題をより取り扱いやすくして，&lt;strong>およそ6回に1回程度の割合で1の目が出ることを，より直接的に示せないかを検討します．&lt;/strong>&lt;/p>
&lt;h2 id="確率変数">
 確率変数
 &lt;a class="anchor" href="#%e7%a2%ba%e7%8e%87%e5%a4%89%e6%95%b0">#&lt;/a>
&lt;/h2>
&lt;p>まずは，確率変数の定義について述べます．&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>&lt;b>Definition 1&lt;/b>.&lt;/p>
&lt;ol>
&lt;li>\(A\) を集合，\(\mathfrak{F}\) をその完全加法族とする．一般に，\((A,\mathfrak{F})\) を &lt;strong>可測空間&lt;/strong> という．また，\((A,\mathfrak{F}),(B,\mathfrak{G})\) を可測空間とするとき，関数 \(F:A\to B\) を \(F:(A,\mathfrak{F})\to(B,\mathfrak{B})\) と表す．&lt;/li>
&lt;li>\((A,\mathfrak{F}),(B,\mathfrak{G})\) を可測空間とする．関数 \(F:(A,\mathfrak{F})\to (B,\mathfrak{F})\) が，任意の \(b\in B\) について \(F^{-1}(b)=\{a\in A\mid F(a)=b\}\in\mathfrak{F}\) であるとき，関数 \(F\) を&lt;strong>可測関数&lt;/strong>と呼ぶ．&lt;/li>
&lt;li>\(\mathbb{R}\) の開集合全体の集合を \(\mathfrak{O}(\mathbb{R})\) と表す．\(\mathfrak{O}(\mathbb{R})\) を含む最小の完全加法族を \(\mathfrak{B}(\mathbb{R})\) と表す．&lt;/li>
&lt;li>\(\Omega,\mathfrak{F}\) を標本空間とする，\(X:(\Omega,\mathfrak{F})\to(\mathbb{R},\mathfrak{B}(\mathbb{R}))\) が可測関数のとき，\(X\) を&lt;strong>確率変数&lt;/strong>という．&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>なお，可測空間も標本空間も集合とその完全加法族の組なので，実質的には同じものですが，数理統計の文脈では，可測空間のことを標本空間と呼ぶ，という理解でよいです．また，本来は &lt;span>
 \(\mathfrak{B}(\mathbb{R})\)
&lt;/span>
 の存在を示す必要がありますが，ここでは認めるものとします．&lt;/p>
&lt;p>&lt;span>
 \(X\)
&lt;/span>
 の像 &lt;span>
 \(X(\Omega)=\{x\in\mathbb{R}\mid \exists \omega\in\Omega\,(X(\omega)=x)\}\)
&lt;/span>
 が高々可算のとき，&lt;span>
 \(X\)
&lt;/span>
 は&lt;strong>離散型確率変数&lt;/strong>と呼ばれます．&lt;/p></description></item><item><title>独自ショートコードの定義</title><link>https://htakeuchi0.github.io/docs/hugo/shortcode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/hugo/shortcode/</guid><description>&lt;h1 id="独自ショートコードの定義">
 独自ショートコードの定義
 &lt;a class="anchor" href="#%e7%8b%ac%e8%87%aa%e3%82%b7%e3%83%a7%e3%83%bc%e3%83%88%e3%82%b3%e3%83%bc%e3%83%89%e3%81%ae%e5%ae%9a%e7%be%a9">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>Hugo には，ショートコードと呼ばれるスニペットを定義・利用できる機能があります &lt;a href="#cite:1">[1]&lt;/a>．本ページでは，ショートコードの一例として，&lt;code>theorem-label&lt;/code> という，
&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \(\LaTeX\)
&lt;/span>
でいう定理環境のラベル部分を生成する独自ショートコードを定義する方法について説明します．なお一般に，スニペットとは，再利用可能なソースコード断片を指す言葉です．&lt;/p>
&lt;h2 id="theorem-label-ショートコード">
 &lt;code>theorem-label&lt;/code> ショートコード
 &lt;a class="anchor" href="#theorem-label-%e3%82%b7%e3%83%a7%e3%83%bc%e3%83%88%e3%82%b3%e3%83%bc%e3%83%89">#&lt;/a>
&lt;/h2>
&lt;p>Hugo は markdown で記事を作成できますが，markdown の簡潔に記述できる利点を損なわないよう，ショートコードと呼ばれるスニペットを定義し，利用できる機能があります．&lt;/p>
&lt;p>ここでは，定理環境のラベルを生成する簡単なショートコードを作成します．ここで，定理環境とは，&lt;span>
 \(\LaTeX\)
&lt;/span>
でいう定理環境のような，定理や定義を示すための文章ブロックを指すものとし，そのラベルとは &amp;ldquo;Theorem 2.3&amp;rdquo; のような文章ブロックの冒頭に書かれるラベルを指すものとします．&lt;/p>
&lt;p>&lt;code>theorem-label&lt;/code> ショートコードは以下の要件を満たすものとします．&lt;/p>
&lt;ul>
&lt;li>&amp;ldquo;&lt;strong>Theorem 1&lt;/strong>.&amp;rdquo; のように，定理種類名称と定理番号を太字で表示できて，ピリオドで終わること&lt;/li>
&lt;li>定理種類名称はユーザが指定できること&lt;/li>
&lt;li>定理番号はページごとに，定理種類名称によらず，1からはじまる連番で自動生成されること&lt;/li>
&lt;li>定理番号の前に節番号などの接頭辞を任意でつけられること&lt;/li>
&lt;li>定理番号の後に括弧付きコメントを任意でつけられること&lt;/li>
&lt;/ul>
&lt;p>そこで，&lt;code>theorem-label&lt;/code> ショートコードは以下のように呼び出せるものとします．&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>項番&lt;/th>
 &lt;th>呼び出し方&lt;/th>
 &lt;th>結果&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>1&lt;/td>
 &lt;td>&lt;code>{{&amp;lt; theorem-label name=&amp;quot;Theorem&amp;quot; &amp;gt;}}&lt;/code>&lt;/td>
 &lt;td>&lt;strong>Theorem 1&lt;/strong>.&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>2&lt;/td>
 &lt;td>&lt;code>{{&amp;lt; theorem-label name=&amp;quot;Theorem&amp;quot; section=&amp;quot;5.2&amp;quot; &amp;gt;}}&lt;/code>&lt;/td>
 &lt;td>&lt;strong>Theorem 5.2.2&lt;/strong>.&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>3&lt;/td>
 &lt;td>&lt;code>{{&amp;lt; theorem-label name=&amp;quot;Proposition&amp;quot; section=&amp;quot;3&amp;quot; comment=&amp;quot;補足&amp;quot; &amp;gt;}}&lt;/code>&lt;/td>
 &lt;td>&lt;strong>Theorem 3.3&lt;/strong> (補足).&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>実装例は以下のとおりです．下記ファイルを &lt;code>layout/shortcodes/theorem-label.html&lt;/code> として保存します．&lt;/p></description></item><item><title>配列への参照を返却する関数</title><link>https://htakeuchi0.github.io/docs/cpp/arrp/retarrref/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/arrp/retarrref/</guid><description>&lt;h1 id="配列への参照を返却する関数">
 配列への参照を返却する関数
 &lt;a class="anchor" href="#%e9%85%8d%e5%88%97%e3%81%b8%e3%81%ae%e5%8f%82%e7%85%a7%e3%82%92%e8%bf%94%e5%8d%b4%e3%81%99%e3%82%8b%e9%96%a2%e6%95%b0">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://htakeuchi0.github.io/docs/cpp/fp/retfp/">関数ポインタを返却する関数&lt;/a> のページでは，C++の関数ポインタを返却する関数の宣言が特徴的であることを述べました．&lt;/p>
&lt;p>このページでは，配列への参照を返却する関数の宣言も同様となることをまとめます．&lt;/p>
&lt;p>結論からいうと，要素が5個の配列の const 参照を返す，const 修飾されたメンバ関数は，以下のような宣言になります．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">double&lt;/span> (&lt;span style="color:#f92672">&amp;amp;&lt;/span>A() &lt;span style="color:#66d9ef">const&lt;/span>)[&lt;span style="color:#ae81ff">5&lt;/span>];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="配列への参照を返却する関数-1">
 配列への参照を返却する関数
 &lt;a class="anchor" href="#%e9%85%8d%e5%88%97%e3%81%b8%e3%81%ae%e5%8f%82%e7%85%a7%e3%82%92%e8%bf%94%e5%8d%b4%e3%81%99%e3%82%8b%e9%96%a2%e6%95%b0-1">#&lt;/a>
&lt;/h2>
&lt;p>いま，クラス &lt;code>Array&lt;/code> が生の配列 &lt;code>a_&lt;/code> をもっていて，その配列への const 参照を返す関数を定義したいとします．&lt;/p>
&lt;p>もちろん，生の配列の代わりに &lt;code>std::array&lt;/code> を使ったり，インデックスに対応する要素を返すアクセサを用意したりすれば，その状況にはならないので，実用上は出会うことのないケースと思います．&lt;/p>
&lt;p>クラス &lt;code>Array&lt;/code> を以下のようにします．
要素はデフォルトコンストラクタで指定しておきます．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Array&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Array() &lt;span style="color:#f92672">:&lt;/span> a_{&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>} {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> a_[&lt;span style="color:#ae81ff">5&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>このとき，&lt;code>a_&lt;/code> の const 参照を返す関数 &lt;code>A&lt;/code> を定義します．&lt;/p>
&lt;p>関数ポインタを返却する関数と同様に，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span>[&lt;span style="color:#ae81ff">5&lt;/span>]&lt;span style="color:#f92672">&amp;amp;&lt;/span> A() &lt;span style="color:#66d9ef">const&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> a_; } &lt;span style="color:#75715e">// NG
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>という書き方はできず，以下のような書き方になります．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">double&lt;/span> (&lt;span style="color:#f92672">&amp;amp;&lt;/span>A() &lt;span style="color:#66d9ef">const&lt;/span>)[&lt;span style="color:#ae81ff">5&lt;/span>] { &lt;span style="color:#66d9ef">return&lt;/span> a_; } &lt;span style="color:#75715e">// OK
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これは以下のように分解されます．&lt;/p>
&lt;pre tabindex="0">&lt;code>const double (&amp;amp; A () const )[5];
~~~~~~~~~~~~~~~ ==^^ +++++ ~~~~
 | | | |_ メンバ関数 A の const 修飾
 | | | | 
 | | | |
 | | |_ メンバ関数 A の引数リスト
 | | () |
 | | |
 | |__ メンバ関数名
 | A |
 | |
 |_______ 戻り値の型 _________|
 const double (&amp;amp;)[5]
&lt;/code>&lt;/pre>&lt;p>ちなみに，&lt;code>noexcept&lt;/code> にしたい場合は以下です．&lt;/p></description></item><item><title>関数への参照</title><link>https://htakeuchi0.github.io/docs/cpp/fp/fref/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/fref/</guid><description>&lt;h1 id="関数への参照">
 関数への参照
 &lt;a class="anchor" href="#%e9%96%a2%e6%95%b0%e3%81%b8%e3%81%ae%e5%8f%82%e7%85%a7">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>前ページまでで，関数ポインタとその周辺事項について説明しました．
本ページでは，関数への参照型について説明します．&lt;/p>
&lt;h2 id="関数への参照型">
 関数への参照型
 &lt;a class="anchor" href="#%e9%96%a2%e6%95%b0%e3%81%b8%e3%81%ae%e5%8f%82%e7%85%a7%e5%9e%8b">#&lt;/a>
&lt;/h2>
&lt;p>戻り値の型が &lt;code>T&lt;/code>, 第 
&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \(k\)
&lt;/span>
 番目の引数の型が &lt;code>Sk&lt;/code> である関数への関数ポインタ型は，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> fp_t &lt;span style="color:#f92672">=&lt;/span> T (&lt;span style="color:#f92672">*&lt;/span>)(S1, S2,..., Sn);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>または，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> f_t &lt;span style="color:#f92672">=&lt;/span> T(S1, S2,..., Sn);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> fp_t &lt;span style="color:#f92672">=&lt;/span> f_t&lt;span style="color:#f92672">*&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>として定義できるのでした．&lt;/p>
&lt;p>ここで，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> fref_t &lt;span style="color:#f92672">=&lt;/span> T (&lt;span style="color:#f92672">&amp;amp;&lt;/span>)(S1, S2,..., Sn);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>または，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> f_t &lt;span style="color:#f92672">=&lt;/span> T(S1, S2,..., Sn);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> fref_t &lt;span style="color:#f92672">=&lt;/span> f_t&lt;span style="color:#f92672">&amp;amp;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>とすると，&lt;strong>関数への参照型&lt;/strong> をつくることができます．&lt;/p>
&lt;p>つまり，下記のコードをコンパイルして実行することができます．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;exception&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> fref_t &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> (&lt;span style="color:#f92672">&amp;amp;&lt;/span>)(&lt;span style="color:#66d9ef">double&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">Newton&lt;/span>(fref_t f, fref_t df, &lt;span style="color:#66d9ef">double&lt;/span> x0, &lt;span style="color:#66d9ef">double&lt;/span> eps&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1.0e-10&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>size_t loop_max&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1024&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> x0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>size_t i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> loop_max; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">-=&lt;/span> f(x) &lt;span style="color:#f92672">/&lt;/span> df(x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>abs(f(x)) &lt;span style="color:#f92672">&amp;lt;&lt;/span> eps) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>runtime_error(&lt;span style="color:#e6db74">&amp;#34;Convergence error: This method did not converge.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x&lt;span style="color:#f92672">*&lt;/span>x &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">df&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">*&lt;/span>x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> x0 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1.0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> Newton(f, df, x0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl; &lt;span style="color:#75715e">// 1.41421
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>関数ポインタ版に対するメリットとして，関数が &lt;code>nullptr&lt;/code> で渡されるおそれがないことが挙げられます．
ただし，&lt;code>std::function&lt;/code> を使えばその問題は発生しないため，あえて利用することはないと思います．&lt;/p></description></item><item><title>autoconf プロジェクト (4)</title><link>https://htakeuchi0.github.io/docs/cpp/env/autoconf4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/env/autoconf4/</guid><description>&lt;h1 id="autoconf-プロジェクト-4">
 autoconf プロジェクト (4)
 &lt;a class="anchor" href="#autoconf-%e3%83%97%e3%83%ad%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88-4">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://htakeuchi0.github.io/docs/cpp/env/autoconf3/">前ページ&lt;/a>までで，&lt;a href="https://htakeuchi0.github.io/docs/cpp/env/make/">Makefile プロジェクト&lt;/a> とほとんど同様の機能をもつ autoconf プロジェクトの作成方法を説明しました．&lt;/p>
&lt;p>本ページでは，これまでの説明の総括として，&lt;a href="https://htakeuchi0.github.io/docs/cpp/env/autoconf/">autoconf プロジェクト(1)&lt;/a> や &lt;a href="https://htakeuchi0.github.io/docs/cpp/env/autoconf2/">autoconf プロジェクト (2)&lt;/a> と同じ節構成で，&lt;a href="https://htakeuchi0.github.io/docs/cpp/env/make/">Makefile プロジェクト&lt;/a> をもとにした autoconf プロジェクトの作成手順を説明します．&lt;/p>
&lt;h2 id="github-リポジトリ">
 Github リポジトリ
 &lt;a class="anchor" href="#github-%e3%83%aa%e3%83%9d%e3%82%b8%e3%83%88%e3%83%aa">#&lt;/a>
&lt;/h2>
&lt;p>本ページで説明するディレクトリ構成の autoconf プロジェクトは，以下の Github リポジトリ &lt;a href="#cite:1">[1]&lt;/a> として公開しています．&lt;/p>
&lt;p>&lt;a href="https://github.com/htakeuchi0/autoconf_sample">https://github.com/htakeuchi0/autoconf_sample&lt;/a>&lt;/p>
&lt;p>本ページは CC BY 4.0 のもとで提供していますが，このリポジトリはMITライセンスで公開しています．&lt;/p>
&lt;h2 id="準備">
 準備
 &lt;a class="anchor" href="#%e6%ba%96%e5%82%99">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://htakeuchi0.github.io/docs/cpp/env/make/">Makefile プロジェクト&lt;/a> のリポジトリからスタートします． &lt;br>
初期状態のディレクトリ構成は以下のとおりです．&lt;/p>
&lt;pre tabindex="0">&lt;code>|- cpp_env_sample/
 |- Doxyfile - doxygen設定ファイル
 |- LICENSE - ライセンスファイル
 |- Makefile - makeファイル
 |- README.md - READMEファイル
 |- include/ - ヘッダファイル
 | |- cpp_env_sample/
 | |- example.h
 |
 |- main/ - メインファイル
 | |- main.cc
 |
 |- scripts/ - 環境構築用スクリプト
 | |- install_doxygen.sh
 | |- install_gtest.sh
 | |- install_lcov.sh
 |
 |- src/ - ソースファイル
 | |- example.cc
 |
 |- test/ - テストファイル
 |- gtest_example.cc
&lt;/code>&lt;/pre>&lt;p>まず，これから自動生成する Makefile を削除しておきます．&lt;/p></description></item><item><title>Book テーマの hint ショートコードブロック内に数式を表示する際の注意</title><link>https://htakeuchi0.github.io/docs/hugo/book_katex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/hugo/book_katex/</guid><description>&lt;h1 id="book-テーマの-hint-ショートコードブロック内に数式を表示する際の注意">
 Book テーマの hint ショートコードブロック内に数式を表示する際の注意
 &lt;a class="anchor" href="#book-%e3%83%86%e3%83%bc%e3%83%9e%e3%81%ae-hint-%e3%82%b7%e3%83%a7%e3%83%bc%e3%83%88%e3%82%b3%e3%83%bc%e3%83%89%e3%83%96%e3%83%ad%e3%83%83%e3%82%af%e5%86%85%e3%81%ab%e6%95%b0%e5%bc%8f%e3%82%92%e8%a1%a8%e7%a4%ba%e3%81%99%e3%82%8b%e9%9a%9b%e3%81%ae%e6%b3%a8%e6%84%8f">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>Book テーマ &lt;a href="#cite:1">[1]&lt;/a> では，&lt;span>
 \(\KaTeX\)
&lt;/span>
を使うための &lt;code>katex&lt;/code> ショートコードが用意されています &lt;a href="#cite:2">[2]&lt;/a>．
また，目立たせたい情報を文書ブロックとして表示できる，&lt;code>hint&lt;/code> ショートコードが用意されています &lt;a href="#cite:3">[3]&lt;/a>．&lt;/p>
&lt;p>しかし，&lt;code>hint&lt;/code> ショートコードブロックの中で &lt;code>katex&lt;/code> ショートコードを使う場合，うまく数式が表示できないことがあります．
本ページでは，&lt;code>hint&lt;/code> ショートコードブロック内で数式を表示する場合の注意について説明します．&lt;/p>
&lt;h2 id="hint-ショートコードの使いかた">
 &lt;code>hint&lt;/code> ショートコードの使いかた
 &lt;a class="anchor" href="#hint-%e3%82%b7%e3%83%a7%e3%83%bc%e3%83%88%e3%82%b3%e3%83%bc%e3%83%89%e3%81%ae%e4%bd%bf%e3%81%84%e3%81%8b%e3%81%9f">#&lt;/a>
&lt;/h2>
&lt;p>公式の説明 &lt;a href="#cite:3">[3]&lt;/a> をもとに，markdown での記述例と，出力結果を説明します．&lt;code>hint&lt;/code> ショートコードは第1引数によって，背景色を変えることができます．&lt;/p>
&lt;h3 id="第1引数なし">
 第1引数：なし
 &lt;a class="anchor" href="#%e7%ac%ac1%e5%bc%95%e6%95%b0%e3%81%aa%e3%81%97">#&lt;/a>
&lt;/h3>
&lt;p>markdown の記述例は以下のとおりです．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-md" data-lang="md">&lt;span style="display:flex;">&lt;span>{{% hint %}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ヒント．
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{% /hint %}}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>出力結果は以下のとおりです．&lt;/p>
&lt;blockquote class="book-hint ">
&lt;p>ヒント．&lt;/p>
&lt;/blockquote>
&lt;h3 id="第1引数info">
 第1引数：info
 &lt;a class="anchor" href="#%e7%ac%ac1%e5%bc%95%e6%95%b0info">#&lt;/a>
&lt;/h3>
&lt;p>markdown の記述例は以下のとおりです．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-md" data-lang="md">&lt;span style="display:flex;">&lt;span>{{% hint info %}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ヒント．
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{% /hint %}}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>出力結果は以下のとおりです．&lt;/p>
&lt;blockquote class="book-hint info">
&lt;p>ヒント．&lt;/p>
&lt;/blockquote>
&lt;h3 id="第1引数warning">
 第1引数：warning
 &lt;a class="anchor" href="#%e7%ac%ac1%e5%bc%95%e6%95%b0warning">#&lt;/a>
&lt;/h3>
&lt;p>markdown の記述例は以下のとおりです．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-md" data-lang="md">&lt;span style="display:flex;">&lt;span>{{% hint warning %}}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ヒント．
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{% /hint %}}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>出力結果は以下のとおりです．&lt;/p></description></item><item><title>サイコロを無限回投げる場合の確率モデル</title><link>https://htakeuchi0.github.io/docs/math/stat/dice/dice_inf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/math/stat/dice/dice_inf/</guid><description>&lt;h1 id="サイコロを無限回投げる場合の確率モデル">
 サイコロを無限回投げる場合の確率モデル
 &lt;a class="anchor" href="#%e3%82%b5%e3%82%a4%e3%82%b3%e3%83%ad%e3%82%92%e7%84%a1%e9%99%90%e5%9b%9e%e6%8a%95%e3%81%92%e3%82%8b%e5%a0%b4%e5%90%88%e3%81%ae%e7%a2%ba%e7%8e%87%e3%83%a2%e3%83%87%e3%83%ab">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>前ページまでで，サイコロを繰り返し投げる試行の確率モデルを定義しました．しかし，投げる回数 
&lt;link rel="stylesheet" href="https://htakeuchi0.github.io/katex/katex.min.css" />
&lt;script defer src="https://htakeuchi0.github.io/katex/katex.min.js">&lt;/script>
&lt;script defer src="https://htakeuchi0.github.io/katex/auto-render.min.js" onload="renderMathInElement(document.body);">&lt;/script>&lt;span>
 \(N\)
&lt;/span>
 を固定した場合でしか説明していません．&lt;/p>
&lt;p>本ページでは，サイコロを無限回投げる場合の確率モデルについて説明します．有限の場合ほど明らかではないので，ひとつずつ確認しながら構成します．&lt;/p>
&lt;h2 id="確率の定義">
 確率の定義
 &lt;a class="anchor" href="#%e7%a2%ba%e7%8e%87%e3%81%ae%e5%ae%9a%e7%be%a9">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://htakeuchi0.github.io/docs/math/stat/dice/dice_basic/#%e7%a2%ba%e7%8e%87%e3%81%ae%e5%ae%9a%e7%be%a9">既に述べたとおり&lt;/a>，&lt;span>
 \(\Omega\)
&lt;/span>
 を集合，&lt;span>
 \(\mathfrak{F}\)
&lt;/span>
 を &lt;span>
 \(\Omega\)
&lt;/span>
 の完全加法族としたとき，以下を満たす関数 &lt;span>
 \(P:\mathfrak{F}\to\mathbb{R}\)
&lt;/span>
 を確率と呼ぶのでした．&lt;/p>
&lt;ol>
&lt;li>&lt;span>
 \(A\in\mathfrak{F}\)
&lt;/span>
 ならば &lt;span>
 \(P(A)\ge0\)
&lt;/span>
,&lt;/li>
&lt;li>&lt;span>
 \(P(\Omega)=1\)
&lt;/span>
,&lt;/li>
&lt;li>&lt;span>
 \(A_1,A_2,\dots\in\mathfrak{F}\)
&lt;/span>
 が互いに素ならば，&lt;span>
 \(P(\sum_{i=1}^{\infty}A_i)=\sum_{i=1}^{\infty}P(A_i)\)
&lt;/span>
.&lt;/li>
&lt;/ol>
&lt;p>また，&lt;span>
 \((\Omega,\mathfrak{F},P)\)
&lt;/span>
 を確率空間と呼ぶのでした．&lt;/p>
&lt;h2 id="サイコロを無限回投げる場合を表す確率空間の具体的構成">
 サイコロを無限回投げる場合を表す確率空間の具体的構成
 &lt;a class="anchor" href="#%e3%82%b5%e3%82%a4%e3%82%b3%e3%83%ad%e3%82%92%e7%84%a1%e9%99%90%e5%9b%9e%e6%8a%95%e3%81%92%e3%82%8b%e5%a0%b4%e5%90%88%e3%82%92%e8%a1%a8%e3%81%99%e7%a2%ba%e7%8e%87%e7%a9%ba%e9%96%93%e3%81%ae%e5%85%b7%e4%bd%93%e7%9a%84%e6%a7%8b%e6%88%90">#&lt;/a>
&lt;/h2>
&lt;p>以降では，サイコロを無限回投げる場合を表す確率空間 &lt;span>
 \((\Omega_{\infty},\mathfrak{F}_{\infty},P_{\infty})\)
&lt;/span>
 を具体的に構成します．&lt;/p>
&lt;h3 id="hahahugoshortcode46s13hbhb-の構成">
 &lt;span>
 \(\Omega_\infty\)
&lt;/span>
 の構成
 &lt;a class="anchor" href="#hahahugoshortcode46s13hbhb-%e3%81%ae%e6%a7%8b%e6%88%90">#&lt;/a>
&lt;/h3>
&lt;p>&lt;span>
 \(\Omega_1=\{\omega_1,\omega_2,\dots,\omega_6\}\)
&lt;/span>
 とし，&lt;span>
 \(\Omega_{\infty}\)
&lt;/span>
 を，&lt;/p>
&lt;span>
 \[
\Omega_{\infty}=\{(\omega^i)_{i\in\mathbb{N}}\mid\forall i\in\mathbb{N}\,(\omega^i\in\Omega_1)\}
\]
&lt;/span>

&lt;p>つまり，&lt;span>
 \(\Omega_{\infty}=\Omega^{\mathbb{N}}\)
&lt;/span>
 とします&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;sup>, &lt;/sup>&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>．&lt;/p>
&lt;h3 id="hahahugoshortcode46s25hbhb-の構成">
 &lt;span>
 \(\mathfrak{F}_{\infty},P_{\infty}\)
&lt;/span>
 の構成
 &lt;a class="anchor" href="#hahahugoshortcode46s25hbhb-%e3%81%ae%e6%a7%8b%e6%88%90">#&lt;/a>
&lt;/h3>
&lt;p>&lt;span>
 \(\mathfrak{F}_{\infty},P_{\infty}\)
&lt;/span>
 を定めるには準備が必要です．
まず，&lt;span>
 \(1\le k\in\mathbb{N}\)
&lt;/span>
 について，
&lt;span>
 \[
N^{(k)}=\{(n_1,n_2,\dots,n_k)\in\mathbb{N}^k\mid 1\le n_1&lt;\dots &lt; n_k\}
\]
&lt;/span>
&lt;/p></description></item><item><title>関数ポインタを返却する関数</title><link>https://htakeuchi0.github.io/docs/cpp/fp/retfp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/retfp/</guid><description>&lt;h1 id="関数ポインタを返却する関数">
 関数ポインタを返却する関数
 &lt;a class="anchor" href="#%e9%96%a2%e6%95%b0%e3%83%9d%e3%82%a4%e3%83%b3%e3%82%bf%e3%82%92%e8%bf%94%e5%8d%b4%e3%81%99%e3%82%8b%e9%96%a2%e6%95%b0">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>前ページまでで，関数ポインタを引数にとる関数を例示しました．&lt;/p>
&lt;p>本ページでは，逆に関数ポインタを返却する関数について述べます．&lt;/p>
&lt;p>結論からいうと，文字列を受け取って，&lt;code>(double, double) -&amp;gt; double&lt;/code> の関数へのポインタを返す関数は，以下のような（奇妙な）宣言になります．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">double&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>From(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;amp;&lt;/span> label))(&lt;span style="color:#66d9ef">double&lt;/span>, &lt;span style="color:#66d9ef">double&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="文字列に対応する関数を返却する関数オブジェクト指向">
 文字列に対応する関数を返却する関数（オブジェクト指向）
 &lt;a class="anchor" href="#%e6%96%87%e5%ad%97%e5%88%97%e3%81%ab%e5%af%be%e5%bf%9c%e3%81%99%e3%82%8b%e9%96%a2%e6%95%b0%e3%82%92%e8%bf%94%e5%8d%b4%e3%81%99%e3%82%8b%e9%96%a2%e6%95%b0%e3%82%aa%e3%83%96%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e6%8c%87%e5%90%91">#&lt;/a>
&lt;/h2>
&lt;p>いま，&lt;code>&amp;quot;ADD&amp;quot;, &amp;quot;SUB&amp;quot;&lt;/code> という文字列を指定したら，その文字列に対応する関数を返却する関数を考えます．&lt;/p>
&lt;p>オブジェクト指向プログラミングでは，以下のような実装が考えられます．&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;memory&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Operator&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#f92672">~&lt;/span>Operator() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> &lt;span style="color:#a6e22e">Compute&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span>, &lt;span style="color:#66d9ef">double&lt;/span>) &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Add&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> Operator {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> Compute(&lt;span style="color:#66d9ef">double&lt;/span> a, &lt;span style="color:#66d9ef">double&lt;/span> b) &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> b; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Sub&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> Operator {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> Compute(&lt;span style="color:#66d9ef">double&lt;/span> a, &lt;span style="color:#66d9ef">double&lt;/span> b) &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">-&lt;/span> b; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>unique_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>Operator&lt;span style="color:#f92672">&amp;gt;&lt;/span> From(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;amp;&lt;/span> label) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (label &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;ADD&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>make_unique&lt;span style="color:#f92672">&amp;lt;&lt;/span>Add&lt;span style="color:#f92672">&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (label &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;SUB&amp;#34;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>make_unique&lt;span style="color:#f92672">&amp;lt;&lt;/span>Sub&lt;span style="color:#f92672">&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>invalid_argument(&lt;span style="color:#e6db74">&amp;#34;Not implemented.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> add &lt;span style="color:#f92672">=&lt;/span> From(&lt;span style="color:#e6db74">&amp;#34;ADD&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; + &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; = &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> add&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Compute(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">auto&lt;/span> sub &lt;span style="color:#f92672">=&lt;/span> From(&lt;span style="color:#e6db74">&amp;#34;SUB&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; - &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; = &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> sub&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Compute(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>インタフェースクラス &lt;code>Operator&lt;/code> が &lt;code>Compute&lt;/code> メソッドの実装を要求し，移譲された継承クラスの実装関数で，それぞれ具体的なロジックを定義しています．&lt;/p></description></item><item><title>CMake プロジェクト (1)</title><link>https://htakeuchi0.github.io/docs/cpp/env/cmake/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/env/cmake/</guid><description>&lt;h1 id="cmake-プロジェクト-1">
 CMake プロジェクト (1)
 &lt;a class="anchor" href="#cmake-%e3%83%97%e3%83%ad%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88-1">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>前ページまでで，autoconf プロジェクトの作成方法を説明しました．&lt;/p>
&lt;p>本ページでは，CMake プロジェクトの作成方法を説明します．&lt;/p>
&lt;p>まずは，実行可能ファイルのビルドと Google Test が可能なものを作成します．&lt;/p>
&lt;h2 id="github-リポジトリ">
 Github リポジトリ
 &lt;a class="anchor" href="#github-%e3%83%aa%e3%83%9d%e3%82%b8%e3%83%88%e3%83%aa">#&lt;/a>
&lt;/h2>
&lt;h2 id="準備">
 準備
 &lt;a class="anchor" href="#%e6%ba%96%e5%82%99">#&lt;/a>
&lt;/h2>
&lt;p>&lt;a href="https://htakeuchi0.github.io/docs/cpp/env/make/">Makefile プロジェクト&lt;/a> のリポジトリからスタートします． &lt;br>
初期状態のディレクトリ構成は以下のとおりです．&lt;/p>
&lt;pre tabindex="0">&lt;code>|- cpp_env_sample/
 |- Doxyfile - doxygen設定ファイル
 |- LICENSE - ライセンスファイル
 |- Makefile - makeファイル
 |- README.md - READMEファイル
 |- include/ - ヘッダファイル
 | |- cpp_env_sample/
 | |- example.h
 |
 |- main/ - メインファイル
 | |- main.cc
 |
 |- scripts/ - 環境構築用スクリプト
 | |- install_doxygen.sh
 | |- install_gtest.sh
 | |- install_lcov.sh
 |
 |- src/ - ソースファイル
 | |- example.cc
 |
 |- test/ - テストファイル
 |- gtest_example.cc
&lt;/code>&lt;/pre>&lt;p>まず，これから自動生成する Makefile を削除しておきます． &lt;br>
また，&lt;code>scripts/install_gtest.sh&lt;/code> は不要のため削除しておきます．&lt;/p></description></item><item><title>CMake プロジェクト (2)</title><link>https://htakeuchi0.github.io/docs/cpp/env/cmake2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/env/cmake2/</guid><description>&lt;h1 id="cmake-プロジェクト-2">
 CMake プロジェクト (2)
 &lt;a class="anchor" href="#cmake-%e3%83%97%e3%83%ad%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88-2">#&lt;/a>
&lt;/h1>
&lt;h2 id="概要">
 概要
 &lt;a class="anchor" href="#%e6%a6%82%e8%a6%81">#&lt;/a>
&lt;/h2>
&lt;p>前ページでは，CMake プロジェクトの基本的な作り方を説明しました．&lt;/p>
&lt;p>本ページでは，&lt;code>make docs&lt;/code> で Doxygen ドキュメントが生成できたり，&lt;code>make lcov&lt;/code> でカバレッジ計測のレポートが生成できたりするように拡張します．&lt;/p>
&lt;p>これらは，&lt;code>ADD_CUSTOM_TARGET&lt;/code>. &lt;code>ADD_CUSTOM_COMMAND&lt;/code> を使うと実現できます．&lt;/p>
&lt;h2 id="github-リポジトリ">
 Github リポジトリ
 &lt;a class="anchor" href="#github-%e3%83%aa%e3%83%9d%e3%82%b8%e3%83%88%e3%83%aa">#&lt;/a>
&lt;/h2>
&lt;p>本ページで説明するディレクトリ構成の CMake プロジェクトは，以下の Github リポジトリ &lt;a href="#cite:1">[1]&lt;/a> として公開しています．&lt;/p>
&lt;p>&lt;a href="https://github.com/htakeuchi0/cmake_sample">https://github.com/htakeuchi0/cmake_sample&lt;/a>&lt;/p>
&lt;p>本ページは CC BY 4.0 のもとで提供していますが，このリポジトリはMITライセンスで公開しています．&lt;/p>
&lt;h2 id="準備">
 準備
 &lt;a class="anchor" href="#%e6%ba%96%e5%82%99">#&lt;/a>
&lt;/h2>
&lt;p>今回も &lt;a href="https://htakeuchi0.github.io/docs/cpp/env/make/">Makefile プロジェクト&lt;/a> のリポジトリからスタートします． &lt;br>
初期状態のディレクトリ構成は以下のとおりです．&lt;/p>
&lt;pre tabindex="0">&lt;code>|- cpp_env_sample/
 |- Doxyfile - doxygen設定ファイル
 |- LICENSE - ライセンスファイル
 |- Makefile - makeファイル
 |- README.md - READMEファイル
 |- include/ - ヘッダファイル
 | |- cpp_env_sample/
 | |- example.h
 |
 |- main/ - メインファイル
 | |- main.cc
 |
 |- scripts/ - 環境構築用スクリプト
 | |- install_doxygen.sh
 | |- install_gtest.sh
 | |- install_lcov.sh
 |
 |- src/ - ソースファイル
 | |- example.cc
 |
 |- test/ - テストファイル
 |- gtest_example.cc
&lt;/code>&lt;/pre>&lt;p>まず，これから自動生成する Makefile を削除しておきます． &lt;br>
また，&lt;code>scripts/install_gtest.sh&lt;/code> は不要のため削除しておきます．&lt;/p></description></item></channel></rss>