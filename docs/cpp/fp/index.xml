<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>関数ポインタ on htakeuchi0 のノート</title><link>https://htakeuchi0.github.io/docs/cpp/fp/</link><description>Recent content in 関数ポインタ on htakeuchi0 のノート</description><generator>Hugo</generator><language>ja-jp</language><atom:link href="https://htakeuchi0.github.io/docs/cpp/fp/index.xml" rel="self" type="application/rss+xml"/><item><title>関数ポインタとその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/fp/fp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/fp/</guid><description>関数ポインタとその周辺 # 概要 # ポインタ (pointer) とは，メモリアドレスを格納するためのオブジェクトのことです． C++ では，変数のメモリアドレスはもちろん，関数のエントリーポイントとなるメモリアドレスを格納することができます．
本ページでは，Newton 法という数値解法の実装を例とし，関数ポインタについて説明します．
Newton 法とその素朴な実装 # Newton 法とは，導関数が既知である実数値関数の零点を求める数値解法のひとつです． 近似解を中心に関数を一次近似（接線で近似）し，その一次関数の零点（その接線と \(x\) 軸の交点）に近似解を更新する，という操作を繰り返すことで数値的解を求めます．
具体的にいえば，初期値を \(x_0\) としたとき，近似解の更新式は，
\[x_{k&amp;#43;1}=x_k-\frac{f(x_k)}{f&amp;#39;(x_k)},\quad k=0,1,\dots\] となります．
関数 f, 導関数 df に対して，初期点 x0 に最も近い零点を求めるための関数 Newton の素朴な実装として，以下が考えられます． ここでは，収束判定条件を \(|f(x_k)|&amp;lt;\epsilon\) \((\epsilon&amp;gt;0)\) とし， 最大反復回数 loop_max を超えたら収束しなかった旨のエラーを返すようにしています．
#include &amp;lt;cmath&amp;gt; #include &amp;lt;exception&amp;gt; #include &amp;lt;iostream&amp;gt; double f(double x) { return x*x - 2; } double df(double x) { return 2*x; } double Newton(double x0, double eps=1.0e-10, std::size_t loop_max=1024) { double x = x0; for (std::size_t i = 0; i &amp;lt; loop_max; i++) { x -= f(x) / df(x); if (std::abs(f(x)) &amp;lt; eps) { return x; } } throw std::runtime_error(&amp;#34;Convergence error: This method did not converge.</description></item><item><title>メンバ関数ポインタとその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/fp/mfp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/mfp/</guid><description>メンバ関数ポインタとその周辺 # 概要 # ポインタ (pointer) とは，メモリアドレスを格納するためのオブジェクトのことで，関数のエントリーポイントとなるメモリアドレスを格納できます（関数ポインタ）．
前ページでは，関数ポインタを利用して，関数を引数にとる関数が実現できることを確認しました． 本ページでは，関数がクラスのメンバ関数の場合にどうなるかについて説明します．
クラス定義とオブジェクト指向に基づく通常の対応 # 前節の関数を多項式関数に限定します． そのため，多項式関数を表すクラス Polynomial を以下のように用意したとします．
#include &amp;lt;initializer_list&amp;gt; #include &amp;lt;vector&amp;gt; /** * @brief 多項式関数を表すクラス． * * 例えば f(x) = x^2 - 2 の表現と f(1.0) の計算は以下のようにできる． * * Polynomial f = { -2, 0, 1 }; // x^2 - 2 = -2 + 0x + 1x^2 * std::cout &amp;lt;&amp;lt; f.Eval(1.0) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;; // -1.0 (=f(1.0)) */ class Polynomial { public: Polynomial(std::initializer_list&amp;lt;double&amp;gt; init) : coeffs_(init.</description></item><item><title>std::function とその周辺</title><link>https://htakeuchi0.github.io/docs/cpp/fp/stdfunc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/stdfunc/</guid><description>std::function とその周辺 # 概要 # 前ページまでは，関数ポインタやメンバ関数ポインタについて説明しました．本ページでは，標準ライブラリ std::function を利用する方法について説明します．
実用上は std::function を使う方法で十分と思います．
std::function について # functional ヘッダを include すると，std::function が利用できます． std::function の定義は以下のとおりです [1]． テンプレートクラスですが，テンプレートの特殊化によって，関数型のみが受け付けられるようになっています．
template &amp;lt;class&amp;gt; class function; /* undefined */ template &amp;lt;class R, class... Args&amp;gt; class function&amp;lt;R(Args...)&amp;gt;; まず，Args... は可変テンプレート引数の型を表します． よって，R(Args...) は 戻り値の型が R で，引数の型が Args... である関数の型です． したがって，Newton 関数を以下のように定義しておけば，f, df は関数を渡せます．
#include &amp;lt;cmath&amp;gt; #include &amp;lt;functional&amp;gt; using func_t = std::function&amp;lt;double(double)&amp;gt;; double Newton(func_t f, func_t df, double x0, double eps=1.0e-10, std::size_t loop_max=1024) { double x = x0; for (std::size_t i = 0; i &amp;lt; loop_max; i++) { x -= f(x) / df(x); if (std::abs(f(x)) &amp;lt; eps) { return x; } } throw std::runtime_error(&amp;#34;Convergence error: This method did not converge.</description></item><item><title>関数への参照</title><link>https://htakeuchi0.github.io/docs/cpp/fp/fref/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://htakeuchi0.github.io/docs/cpp/fp/fref/</guid><description>関数への参照 # 概要 # 前ページまでで，関数ポインタとその周辺事項について説明しました． 本ページでは，関数への参照型について説明します．
関数への参照型 # 戻り値の型が T, 第 \(k\) 番目の引数の型が Sk である関数への関数ポインタ型は，
using fp_t = T (*)(S1, S2,..., Sn); または，
using f_t = T(S1, S2,..., Sn); using fp_t = f_t*; として定義できるのでした．
ここで，
using fref_t = T (&amp;amp;)(S1, S2,..., Sn); または，
using f_t = T(S1, S2,..., Sn); using fref_t = f_t&amp;amp;; とすると，関数への参照型 をつくることができます．
つまり，下記のコードをコンパイルして実行することができます．
#include &amp;lt;cmath&amp;gt; #include &amp;lt;exception&amp;gt; #include &amp;lt;iostream&amp;gt; using fref_t = double (&amp;amp;)(double); double Newton(fref_t f, fref_t df, double x0, double eps=1.</description></item></channel></rss>